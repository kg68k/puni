        - ASSEMBLER MANUAL -

==============================================================================

・レジスタ

01234-6--  d0～d7       データレジスタ
01234-6--  a0～a7       アドレスレジスタ
01234-6--  sp           スタックポインタ(a7 の別名)
01234-6--  usp          ユーザースタックポインタ
01234-6--  pc           プログラムカウンタ
01234-6--  sr           ステータスレジスタ
01234-6--  ccr          コンディションコードレジスタ

01234-6--  opc          オプショナル PC(擬似レジスタ)
--234-6--  zd0～zd7     データレジスタ省略
--234-6--  za0～za7     アドレスレジスタ省略
--234-6--  zsp          スタックポインタ省略(za7 の別名)
--234-6--  zpc          プログラムカウンタ省略

-1234-6--  sfc          ソースファンクションコード
-1234-6--  dfc          ディスティネーションファンクションコード
-1234-6--  vbr          ベクタベースレジスタ

--234----  msp          マスタスタックポインタ
--234----  isp          割り込みスタックポインタ
--234-6--  cacr         キャッシュコントロールレジスタ
--23-----  caar         キャッシュアドレスレジスタ
------6--  buscr        バスコントロールレジスタ
------6--  pcr          プロセッサコンフィグレーションレジスタ

---3----m  crp          CPU ルートポインタ
---346--m  srp          スーパーバイザルートポインタ
---346--m  tc           変換制御レジスタ
---3-----  tt0～tt1     透過変換レジスタ
---34---m  mmusr        MMU ステータスレジスタ(※1)
---34---m  psr          PMMU ステータスレジスタ(※1)

----4-6--  urp          ユーザルートポインタ
----4-6--  itt0～itt1   透過変換レジスタ(命令)
----4-6--  dtt0～dtt1   透過変換レジスタ(データ)
----4-6--  nc           キャッシュ無指定(CINV/CPUSH 命令で使用)
----4-6--  dc           データキャッシュ(CINV/CPUSH 命令で使用)
----4-6--  ic           命令キャッシュ(CINV/CPUSH 命令で使用)
----4-6--  bc           データ/命令キャッシュ(CINV/CPUSH 命令で使用)

--------m  drp          DMA ルートポインタ
--------m  cal          カレントアクセスレベル
--------m  val          有効アクセスレベル
--------m  scc          スタック変更制御
--------m  ac           アクセス制御レジスタ
--------m  pcsr         PMMU キャッシュステータスレジスタ
--------m  bad0～bad7   ブレークポイントアクノリッジデータレジスタ
--------m  bac0～bac7   ブレークポイントアクノリッジ制御レジスタ

----4-6f-  fp0～fp7     浮動小数点データレジスタ
----4-6f-  fpcr         浮動小数点コントロールレジスタ
----4-6f-  fpsr         浮動小数点ステータスレジスタ
----4-6f-  fpiar        浮動小数点命令アドレスレジスタ

01234-6--  r0～r7, r8～r15      d0～d7, a0～a7 の別名
--234-6--  zr0～zr7, zr8～zr15  zd0～zd7, za0～za7 の別名

01234-6fm
||||| ||+- m = 68020 + 68851(PMMU)
||||| |+-- f = 68020/68030 + 68881/68882(FPU)
||||| +--- 6 = 68060 (内蔵 MMU/FPU を含む)
||||+----- 4 = 68040 (内蔵 MMU/FPU を含む)
|||+------ 3 = 68030 (内蔵 MMU を含む)
||+------- 2 = 68020
|+-------- 1 = 68010
+--------- 0 = 68000

レジスタ名の大文字小文字は区別されない。

※1 厳密には mmusr は68030/68040オンチップ MMU 専用レジスタ、psr は68851(PMMU)
    専用レジスタだが、アセンブラでは同じものとして扱われる。

==============================================================================

・整数リテラル

接頭辞
$     16進数(0～9、a～f、A-F)
0x    16進数(0～9、a～f、A-F)
@     8進数(0～7)
0o    8進数(0～7)
%     2進数(0～1)
0b    2進数(0～1)
なし  10進数(0～9)

数字のセパレータとして '_' を使える。

・浮動小数点リテラル

符号は '+'、'-'、または省略('+' として扱われる)。
なお、浮動小数点数を整数に変換した場合は小数点以下切り捨てとなる。

少数点表記
    整数部 + '.' + 小数部
             '.' + 小数部

    小数点と小数部を省略して整数部のみを記述すると、小数点表記ではなく単精度の
    内部表現(整数形式)として扱われるので注意すること。

指数表記
    仮数部(整数部               ) + 'e' + 符号 + 指数部
    仮数部(整数部 + '.'         ) + 'e' + 符号 + 指数部
    仮数部(整数部 + '.' + 小数部) + 'e' + 符号 + 指数部
    仮数部(         '.' + 小数部) + 'e' + 符号 + 指数部

    指数記号 'e' は大文字の 'E' でもよい。
    整数部、小数部、指数部は0～9の数字が使える。

接頭辞(0f)表記
    '0f' + 符号 + 小数点表記
    '0f' + 符号 + 指数表記
    '0f' + 符号 + 10進数の整数

内部表現(接頭辞(!))
    接頭辞 '!' からはじまる規定桁数の16進数。セパレータとして '_' を使える。
    単精度は8桁、倍精度は16桁、拡張精度とパックドデシマルは24桁。

    例: fmove.d #!40510000_00000000,fp0

内部表現(整数形式)
    ロングワード値の整数リテラルを既定の数だけ ',' でつなげて並べる。
    単精度は1個、倍精度は2個、拡張精度とパックドデシマルは3個。

    例: fmove.d #$40510000,0,fp0

==============================================================================

・単項演算子

+ .pos.         そのままの値
- .neg.         符号反転
.not.           ビット単位 NOT
.notb.          ビット単位 NOT の下位ワードの下位バイト
.notw.          ビット単位 NOT の下位ワード
.high.          ロングワード値の下位ワードの上位バイト
.low.           ロングワード値の下位ワードの下位バイト
.highw.         ロングワード値の上位ワード
.loww.          ロングワード値の下位ワード
.nul.           常に0

.sizeof.()      レジスタリストまたは文字列の占有バイト数
                  d0-d7/a0-a7      レジスタ数×4
                  fp0-fp7          レジスタ数×12
                  fpcr/fpsr/fpiar  レジスタ数×4
.defined. .defined.()
                シンボルが定義されていれば-1、そうでなければ0

・二項演算子

* .mul.         乗算
/ .div.         除算
.mod.           剰余

>> .shr.        右へ論理シフト
<< .shl.        左へ論理シフト
.asr.           右へ算術シフト

+ .add.         加算
- .sub.         減算

== =  .eq.      等しければ-1、等しくなければ0
!= <> .ne.      等しくなければ-1、等しければ0
<  .lt.         左被演算子 <  右被演算子なら-1、そうでなければ0
<= .le.         左被演算子 <= 右被演算子なら-1、そうでなければ0
>  .gt.         左被演算子 >  右被演算子なら-1、そうでなければ0
>= .ge.         左被演算子 >= 右被演算子なら-1、そうでなければ0
.<.  .slt.      符号つき .lt.
.<=. .sle.      符号つき .le.
.>.  .sgt.      符号つき .gt.
.>=. .sge.      符号つき .ge.

& .and.         ビット単位 AND
| .or.          ビット単位 OR
^ .xor. .eor.   ビット単位 XOR

・演算子の優先順位

1. ()で囲まれた式(内側がより優先される)
2. 単項演算子
3. 乗算、除算、剰余、シフト
4. 加算、減算
5. 大小比較演算子
6. ビット単位 AND
7. ビット単位 OR、ビット単位 XOR

==============================================================================

・コメントの記述

; から行末まで
* から行末まで
    ただし、* が式(現在のロケーションカウンタ)として解釈されない位置であること。
行頭の # から行末まで
.comment 疑似命令で指定された範囲

==============================================================================

・ローケーションカウンタシンボル

現在処理している行がはじまるローケーションカウンタの値がシンボル * に設定され
る。また、これからコードを出力しようとしているローケーションカウンタの値がシン
ボル $ に設定される。

==============================================================================

・@@ ローカルラベル

ソースコード中にいくつでも置けるラベルとして @@: を定義できる。@f でその位置以
降の最も近い @@: ラベル、@b でその位置以前の最も近い @@: ラベルを参照する。

@@b、@@f で二番目に近いラベル、@@@b、@@@f で三番目に近いラベル……のように、@
の数に応じて遠くの @@: ラベルを参照する。

・数字ローカルラベル

ソースコード中にいくつでも置けるラベルとして 1: ～ 9999: を定義できる。1f ～
9999f でその位置以降の、1b ～ 9999b でその位置以前の最も近い対応するローカルラ
ベルを参照する。

・擬似レジスタ OPC(optional PC)

ディスプレースメント付き PC 間接アドレッシング (d16,pc) で PC の代わりに指定で
きる。ディスプレースメントが16ビットで表現できなくなると、絶対ロングアドレッシ
ングに変更する。

コマンドラインで -b スイッチを指定すると、すべてのディスプレースメント付き PC
間接アドレッシングで PC の代わりに OPC を指定したものとして扱う。

==============================================================================

・JBRA/JBSR/JBcc 命令

それぞれ BRA/BSR/Bcc 命令と同じ処理を行うが、分岐先が16ビットオフセットで表現
できないか、サイズ .L を指定した場合は JMP/JSR 命令に変更する。JBcc は BNcc と
JMP 命令の2命令に変更する。

    JBRA    -> BRA、届かない場合は JMP
    JBRA.S  -> BRA.S
    JBRA.W  -> BRA.W
    JBRA.L  -> JMP

    JBSR    -> BSR、届かない場合は JSR
    JBSR.S  -> BSR.S
    JBSR.W  -> BSR.W
    JBSR.L  -> JSR

    JBcc    -> Bcc、届かない場合は BNcc + JMP
    JBcc.S  -> Bcc.S
    JBcc.W  -> Bcc.W
    JBcc.L  -> BNcc + JMP

コマンドラインで -b スイッチを指定すると、サイズ指定のないすべての BRA/BSR/Bcc
命令を JBRA/JBSR/JBcc 命令として扱う。

==============================================================================

・アセンブラ疑似命令：アセンブラ制御

.text  テキストセクションの指定
  書式  .text

.data  データセクションの指定
  書式  .data

.bss  ブロックストレージセクションの指定
  書式  .bss

  このセクションに確保したメモリ領域は実行ファイルのロード時に0で埋められる。
  ただし、XConverter(CV.X) でX形式実行ファイルに変換した場合は削除される。

.stack  スタックセクションの指定
  書式  .stack

.offset  オフセット表の指定
  書式  .offset <式>

.offsym  特定のシンボルを基準としたオフセット表の指定
  書式  .offsym <式>[,<シンボル>]

  <シンボル> が <式> の値となるように初期値を設定してオフセット表を定義する。
  <シンボル> 省略時は .offset <式> と同じ。.offsym 内で定義したシンボルは、ほ
  かの .offsym で上書きすることができる。

.include  ソースコードの挿入
  書式  .include <ファイル名>

  ファイルをソースコードに挿入する。マクロ内で使用した場合、ファイルはマクロ展
  開後に挿入される。

.comm  コモンエリアの指定
  書式  .comm <ラベル>,<式>

.end  ソースコードの終了指示
  書式  .end <式>

  ソースコードの終了を指示する。.end より後ろの行はすべてコメントとして扱われ
  る。

  <式> を記述するとプログラムの実行開始アドレスの指定となる。ただし、ソースコ
  ード内を指すアドレス値でなければならない。一般的には、テキストセクションで定
  義したラベルそのものを指定する。

  リンカで複数のファイルをリンクする際、<式> が指定されたファイルは一つだけで
  なければならない。複数のファイルで指定されていた場合はエラーになる。

  <式> を省略した場合はプログラムの実行開始アドレスは無指定となり、リンク時に
  ほかのファイルで指定された <式> が採用される。どのファイルでも <式> が指定さ
  れなかった場合はテキストセクションの先頭が実行開始アドレスとなるので、ファイ
  ルのリンク順に留意しなければならない。

  なお、AS.X では <式> 省略時に .end の右にコメントを書けないが、HAS060.X では
  書くことができる(コメント開始記号の * はロケーションカウンタとしての用途もあ
  るが、.end に限ってはコメントとして解釈される)。

.org  ロケーションカウンタの指定
  書式  .org <式>

.comment  コメント行の指定
  書式  .comment <文字列>

  指定された <文字列> がソースコードに現れるまでコメント行とする。<文字列> は
  それぞれの行で空白で区切られた各単語ごとに一致するか比較される。.comment の
  ネストはできない。

  .comment の行頭で定義されたラベルは有効となる。また、<文字列> を含む行は全体
  がコメントとなる。

  AS.X のマニュアルには記載されていないが、<文字列> を省略すると次の一行だけが
  コメント行となる。この書式は HAS060.X でも使用できる。

.fail  エラーの生成
  書式  .fail <式>

.request  リンク時のライブラリを指定
  書式  .request <ファイル名>[,<ファイル名>…]

.cpu  アセンブル対象 CPU の指定
.68000 ～ .68060
  書式  .cpu <式>
        .68000
        .68010
        .68020
        .68030
        .68040
        .68060

.fpid  浮動小数点コプロセッサ ID の指定
  書式  .fpid <式>

.rdata  相対セクションの宣言
.rldata
.rbbs
.rlbbs
.rstack
.rlstack
  書式  .rdata
        .rldata
        .rbbs
        .rlbbs
        .rstack
        .rlstack

.rcomm  相対コモンエリアの指定
.rlcomm
  書式  .rcomm  <ラベル>,<式>
        .rlcomm <ラベル>,<式>

.pragma  最適化オペランドの指定
  書式  .pragma <最適化指定オペランド>

  この機能は実装されておらず、指定しても無視される。

==============================================================================

・アセンブラ疑似命令：外部名指定

.globl  グローバルシンボルの宣言
.global
  書式  .globl  <ラベル>[,<ラベル>…]
        .global <ラベル>[,<ラベル>…]

  ソースコード中に <ラベル> が定義されていれば、それを外部定義名として宣言する。
  そうでなければ外部参照名として宣言する。

.xdef  外部定義名の宣言
.public
.entry
  書式  .xdef   <ラベル>[,<ラベル>…]
        .public <ラベル>[,<ラベル>…]
        .entry  <ラベル>[,<ラベル>…]

.xref  外部参照名の宣言
.extrn
.external
  書式  .xref     <ラベル>[,<ラベル>…]
        .extrn    <ラベル>[,<ラベル>…]
        .external <ラベル>[,<ラベル>…]

==============================================================================

・アセンブラ疑似命令：シンボル値定義

.equ  不変シンボル値の定義
  書式  <シンボル> .equ <式>

.set  可変シンボル値の定義
=
  書式  <シンボル> .set <式>
        <シンボル> = <式>

  シンボルに一時的な値を割りあてる。.set 以外で定義したシンボルも、.set でエラ
  ーにならずに再定義できてしまうので注意すること。

.reg  レジスタリストの定義
  書式  <ラベル> .reg <レジスタリスト>

.fequ  浮動小数シンボルの定義
  書式  <シンボル> .fequ[.<サイズ>] <浮動小数点実数>

  浮動小数点数シンボルを定義する。<浮動小数点実数> に内部表現を使用する場合、
  サイズによって内部表現が変わるため <サイズ> は省略できない。

.fset  浮動小数シンボルへの代入
  書式  <シンボル> .fset[.<サイズ>] <浮動小数点実数>

  浮動小数シンボルへ一時的な値を割り当てる。<浮動小数点実数> に内部表現を使用
  する場合、サイズによって内部表現が変わるため <サイズ> は省略できない。

==============================================================================

・アセンブラ疑似命令：マクロ制御

.macro  マクロ定義の開始
  書式  <マクロ名> .macro [<パラメータリスト>]

  マクロ定義を開始する。

  命令(例: move)や疑似命令(例: if)と同名のマクロを定義するとマクロが優先される
  が、先頭に . を付けて命令(例: .move)や疑似命令(例: .if)を書けば命令や疑似命
  令が優先される。この機能は AS.X にはなく、HAS.X v2.50 以降で拡張されたもので
  ある。

.local  マクロ定義ブロック内の局所的シンボルの宣言
  書式  .local <シンボル>[,<シンボル>…]

  マクロ定義ブロック内だけで局所的に有効なシンボルを宣言する。

  局所的シンボルとして宣言されたシンボルはマクロ展開時に ?? からはじまるシンボ
  ル名に置き換えられ、-d オプションによる外部定義からは除外される。

.endm  マクロ定義の終了
  書式  .endm

.exitm  マクロ展開の打ち切り
  書式  .exitm

.rept  繰り返し命令の設定
  書式  .rept <式>

  .rept 疑似名から .endm 疑似命令の間に記述された行を、<式> の回数だけ繰り返し
  て展開する。<式> は定数でなければならない。

.irp  不定回の繰り返し設定
  書式  .irp <仮引数>[,<実引数>,<実引数>…]

  .irp 疑似名から .endm 疑似命令の間に記述された行を、<仮引数> に <実引数> を
  一つずつ割り当てながら展開する。

  <仮引数> はシンボルとして定義されるのではなく、文字列置換により <実引数> へ
  と置き換わる。そのためシンボルとして使用できない単語(例: 数字のみ)でも指定で
  きる。また .ifdef 疑似命令や .defined. 演算子でも未定義として扱われる。

.irpc  文字の不定回の繰り返し設定
  書式  .irpc <仮引数>[,<文字列>]

  .irpc 疑似名から .endm 疑似命令の間に記述された行を、<仮引数> に <文字列> 内
  の文字を一文字ずつ割り当てながら展開する。

  <仮引数> の扱いについては .irp 疑似命令と同じ。

.sizem  マクロのサイズ指定と引数の個数の受け取り
  書式  .sizem [<サイズのシンボル>[,<引数の個数のシンボル>]]

  マクロ定義中に使うことで、マクロ呼び出し時に指定したオペレーションサイズを
  <サイズのシンボル> に設定する。<引数の個数のシンボル> を指定した場合はマクロ
  呼び出し時に指定した引数の個数をそのシンボルに設定する。これらのシンボルは定
  義中のマクロ内でのみ有効な局所的シンボルとなる。

  マクロ内にあるマクロ定義のなかで使うと、一番外側のマクロに指定されたサイズと
  引数の個数が設定される。

・@からはじまるシンボル名の局所化

マクロ内で @ からはじまるシンボルを定義すると、.local 疑似命令を使わなくても自
動的にマクロ定義ブロック内でのみ有効な局所的シンボルになる。

.local で宣言した局所的シンボルと同じく、マクロ展開時に ?? からはじまるシンボ
ル名に置き換えられ、-d オプションによる外部定義からは除外される。

・特殊記号(実引数)

マクロ展開、.irp 疑似命令での実引数に対して、!、<～>、% が特殊記号として使える。

!
    直後の一文字を文字通りに認識する(, やスペースなどの文字の機能を失わせる)。

<～>
    < と > で囲まれた文字列を文字通りに認識する。

%
    直後に定数を持つシンボルの名前を置くと、その値を引数とする。直後の語がシン
    ボルとして定義されていなかったり、定数でない場合はなにも行わない。

・特殊記号(パラメータ)

通常、文字列内はパラメータの置換対象ではないが、パラメータ名の先頭に & をつけ
ると置換対象になる。

また、引数のセパレータとして & が使用できる。文字列の外に置かれた & は取り除か
れたあとに置換の対象となる。マクロ内に & の文字そのものが必要な場合は && と記
述する。

==============================================================================

・アセンブラ疑似命令：データ出力・領域確保

.dc  定数の出力
  書式  .dc[.<サイズ>] <式>[,<式>…]

  定数を出力する。それぞれの <式> は .dc に指定したサイズで出力されるが、
  .dc.b/.dc.w/.dc.l の個々の <式> にサイズ .b/.w/.l を指定するとそのサイズで出
  力する。

.dcb  定数ブロックの出力
  書式  .dcb[.<サイズ>] <長さ>,<式>

  指定したサイズの定数を <長さ> の回数だけ繰り返し出力する。<長さ> は0～65535
  の範囲で指定できるが、0を指定した場合は何も出力されない。

.ds  メモリ領域の確保
  書式  .ds[.<サイズ>] <長さ>

  指定したサイズの0を <長さ> の回数だけ繰り返し出力する。<長さ> に0を指定した
  場合は何も出力されない。

  テキストセクション、データセクションで使用するとデータとして0が埋め込まれる。
  ブロックストレージセクション、スタックセクションで使用すると領域(アドレス空
  間)の確保のみが行われる。

.even  偶数バンダリの調整
  書式  .even

  偶数バンダリの調整を行う。ロケーションカウンタが奇数の場合は $00 を出力する。

.align  アドレス境界の指定
  書式  .align <境界値>[,<式>]

  アドレス境界を指定する。<境界値> には、2～256の範囲で2の累乗を指定する。

  Human68k では実行ファイルは16の倍数のアドレスにロードされるので、16より大き
  い境界値を指定してもそのとおりになるとは限らない。また、デバイスドライバの場
  合は2の倍数のアドレスにロードされるので、それより大きい境界値ではそのとおり
  になるとは限らない。

  <式> にはアドレス境界を合わせるために出力するデータを、$0000～$ffff の16ビッ
  トの値で指定する。<式> が省略された場合は、現在のセクションが .text セクショ
  ンなら $4e71(NOP の命令コード)、それ以外の場合には $0000 が使用される。

  境界合わせはまず .even 疑似命令と同じ処理が行われてから、<式> の出力がワード
  単位で行われる。

  リンカがセクション先頭のアドレス境界を合わせられるように、ソースファイル中で
  最大の境界値がオブジェクトファイルに出力される。これは HAS.X と hlk.x により
  拡張されたものだが、未対応のリンカでは単に使用されないラベルとして扱われ無視
  される。具体的にはスタックセクションで
      *ファイル名*:: = log2(<境界値>)
  というラベルが定義されたかのような形式となっている。

  HLK-ev、HLKX 以外のリンカではアドレス境界の整合が正しく行われないので注意す
  ること。

.quad  アドレスの4バイト境界の指定
  書式  .quad

  アドレスの4バイト境界を指定する。.align 4 と同じ。

.insert  ファイル内容を埋め込む
  書式  .insert <ファイル名>[,<オフセット>[,<サイズ>]] ...

  ファイルの内容をバイナリデータとして(.dc 疑似命令で指定したのと同じように)埋
  め込む。<オフセット> と <サイズ> を省略するとファイル全体を埋め込む。
  <サイズ> を省略するか -1 を指定するとファイル末尾まで埋め込む。

==============================================================================

・アセンブラ疑似命令：条件つきアセンブリ

.if  条件つきアセンブル
.ifne
  書式  .if   <式>
        .ifne <式>

  <式> が真のときアセンブルを実行する。

.iff  条件つきアセンブル
.ifeq
  書式  .iff <式>
        .ifeq <式>

  <式> が偽のときアセンブルを実行する。

.ifdef  条件つきアセンブル
  書式  .ifdef <シンボル>

  シンボルが定義されているときアセンブルを実行する。

.ifndef  条件つきアセンブル
  書式  .ifndef <シンボル>

  シンボルが定義されていないときアセンブルを実行する。

.elseif  条件つきアセンブル
.elif
  書式  .elseif <式>
        .elif <式>

  それ以前の条件つきアセンブルが実行されておらず、<式> が真のときアセンブルを
  実行する。

.else  条件つきアセンブル
  書式  .else

  それ以前の条件つきアセンブルが実行されていない場合にアセンブルを実行する。
  
.endif  条件つきアセンブルの終了
.endc
  書式  .endif
        .endc

==============================================================================

・アセンブラ疑似命令：リスティング制御

.list  アセンブルリストの出力
  書式  .list

.nlist  アセンブルリストの出力抑止
  書式  .nlist

.page  アセンブルリストの改頁
  書式  .page

.title  アセンブルリストのタイトルの指定
  書式  .title <文字列>

.subttl  アセンブルリストのサブタイトルの指定
  書式  .subttl <文字列>

.lall  マクロ行の出力
  書式  .lall

.sall  マクロ行の出力の抑止
  書式  .sall

.width  リストファイルの表示幅設定
  書式  .width <式>

==============================================================================

・アセンブラ疑似命令：シンボリックデバッグ情報指定

.file  ソースファイル名の出力指定
  書式  .file "<ファイル名>"

.ln  行番号とロケーションの対応の出力指定
  書式  .ln <行番号>[,<ロケーション値>]

.def  シンボルテーブルエントリの作成
.endef
  書式  .def <シンボル>
          (属性を指定する疑似命令)
        .endef

.val  シンボルの値の指定
  書式  .val <式>

.scl  記憶クラスの宣言
  書式  .scl <式>

.type  C 言語における型の宣言
  書式  .type <式>

.tag  タグ名の宣言
  書式  .tag <タグ名>

.line  行番号の指定
  書式  .line <式>

.size  サイズの指定
  書式  .size <式>

.dim  配列の指定
  書式  .dim <式1>[,<式2>…]

==============================================================================

・アセンブラ疑似命令：別名定義

条件分岐命令
    BT   = BRA
    BHS  = BCC
    BLO  = BCS
    BNZ  = BNE
    BZE  = BEQ

    JBT   = JBRA
    JBHS  = JBCC
    JBLO  = JBCS
    JBNZ  = JBNE
    JBZE  = JBEQ

条件セット命令
    SHS  = SCC
    SLO  = SCS
    SNZ  = SNE
    SZE  = SEQ

条件ループ命令
    DBHS  = DBCC
    DBLO  = DBCS
    DBNZ  = DBNE
    DBZE  = DBEQ

条件トラップ命令
    TRAPHS  = TRAPCC
    TRAPLO  = TRAPCS
    TRAPNZ  = TRAPNE
    TRAPZE  = TRAPEQ

加減算命令
    DEC.size  = SUBQ.size #1
    INC.size  = ADDQ.size #1

    CLR.W An  = SUBA.W An,An
      ※上位ワードの値が$0000になるとは限らないので注意すること。
    CLR.L An  = SUBA.L An,An

条件の否定
  　Bcc/JBcc/DBcc/Scc/TRAPcc 命令のコンディションコード cc を Ncc と記述するこ
  とにより、条件を逆にすることができる。
    NCC  = CS
    NCS  = CC
    NEQ  = NE
    NF   = T
    NGE  = LT
    NGT  = LE
    NHI  = LS
    NHS  = CS
    NLE  = GT
    NLO  = CC
    NLS  = HI
    NLT  = GE
    NMI  = PL
    NNE  = EQ
    NNZ  = EQ
    NPL  = MI
    NT   = F
    NVC  = VS
    NVS  = VC
    NZE  = NE

==============================================================================

・プレデファインシンボル

HAS060.Xでは -y/-y1 オプションを指定すると以下のシンボルが自動的に定義される。
    CPU         現在のアセンブル対象の CPU
    __HAS__     HAS.X のバージョン
    __HAS060__  HAS060.X のバージョン
    __DATE__    アセンブル開始時の日付
    __TIME__    アセンブル開始時の時刻

==============================================================================
