        - DOS CALL MANUAL -

==============================================================================

・DOS コール一覧

$ff00   _EXIT           プログラム終了
$ff01   _GETCHAR        キーボード入力(エコーあり)
$ff02   _PUTCHAR        文字表示
$ff03   _COMINP         RS-232C 回線 1 バイト入力
$ff04   _COMOUT         RS-232C 回線 1 バイト出力
$ff05   _PRNOUT         プリンタ 1 文字出力
$ff06   _INPOUT         文字入出力
$ff07   _INKEY          キーボード 1 文字入力(ブレークチェックなし)
$ff08   _GETC           キーボード 1 文字入力(ブレークチェックあり)
$ff09   _PRINT          文字列表示
$ff0a   _GETS           文字列入力(ブレークチェックあり)
$ff0b   _KEYSNS         キー入力状態検査
$ff0c   _KFLUSH         バッファフラッシュ後キーボード入力
$ff0d   _FFLUSH         ディスクリセット
$ff0e   _CHGDRV         カレントドライブ設定
$ff0f   _DRVCTRL        ドライブ状態検査/設定

$ff10   _CONSNS         画面出力検査
$ff11   _PRNSNS         プリンタ出力検査
$ff12   _CINSNS         RS-232C 回線入力検査
$ff13   _COUTSNS        RS-232C 回線出力検査
$ff17   _FATCHK         ファイル連結状態検査
$ff18   _HENDSP         漢字変換行制御
$ff19   _CURDRV         カレントドライブ収得
$ff1a   _GETSS          文字列入力(ブレークチェックなし)
$ff1b   _FGETC          ファイル 1 バイト入力
$ff1c   _FGETS          ファイル文字列入力
$ff1d   _FPUTC          ファイル 1 文字出力
$ff1e   _FPUTS          ファイル文字列出力
$ff1f   _ALLCLOSE       全ファイルクローズ

$ff20   _SUPER          スーパーバイザ/ユーザーモード設定
$ff21   _FNCKEY         再定義可能キー収得/設定
$ff22   _KNJCTRL        仮名漢字変換用ファンクションコール
$ff23   _CONCTRL        コンソール制御/直接出力
$ff24   _KEYCTRL        コンソール状態検査/直接入力
$ff25   _INTVCS         ベクタ処理アドレス設定
$ff26   _PSPSET         プロセス管理ポインタ作成
$ff27   _GETTIM2        時刻収得(ロングワード)
$ff28   _SETTIM2        時刻設定(ロングワード)
$ff29   _NAMESTS        ファイル名展開
$ff2a   _GETDATE        日付収得
$ff2b   _SETDATE        日付設定
$ff2c   _GETTIME        時刻収得
$ff2d   _SETTIME        時刻設定
$ff2e   _VERIFY         ベリファイフラグ設定
$ff2f   _DUP0           ファイルハンドル強制複写

$ff30   _VERNUM         OS バージョン収得
$ff31   _KEEPPR         常駐終了
$ff32   _GETDPB         ドライブパラメータブロック複写
$ff33   _BREAKCK        ブレークチェック設定
$ff34   _DRVXCHG        ドライブ交換
$ff35   _INTVCG         ベクタ処理アドレス収得
$ff36   _DSKFRE         ディスク残量収得
$ff37   _NAMECK         ファイル名展開
$ff39   _MKDIR          サブディレクトリ作成
$ff3a   _RMDIR          サブディレクトリ削除
$ff3b   _CHDIR          カレントディレクトリ変更
$ff3c   _CREATE         ファイル作成
$ff3d   _OPEN           ファイルオープン
$ff3e   _CLOSE          ファイルクローズ
$ff3f   _READ           ファイル入力

$ff40   _WRITE          ファイル出力
$ff41   _DELETE         ファイル削除
$ff42   _SEEK           ファイルポインタ移動
$ff43   _CHMOD          ファイル属性収得/設定
$ff44   _IOCTRL         デバイスドライバ ioctrl 直接入出力
$ff45   _DUP            ファイルハンドル複写
$ff46   _DUP2           ファイルハンドル強制複写
$ff47   _CURDIR         カレントディレクトリ収得
$ff48   _MALLOC         メモリ確保
$ff49   _MFREE          メモリブロック解放
$ff4a   _SETBLOCK       メモリブロック変更
$ff4b   _EXEC           プログラムロード/実行
$ff4c   _EXIT2          終了コード指定終了
$ff4d   _WAIT           プロセス終了コード収得
$ff4e   _FILES          ファイル検索
$ff4f   _NFILES         ファイル次検索

$ff50   (_SETPDB)       (v2) 管理プロセス変更
$ff51   (_GETPDB)       (v2) プロセス情報収得
$ff52   (_SETENV)       (v2) 環境変数設定
$ff53   (_GETENV)       (v2) 環境変数収得
$ff54   (_VERIFYG)      (v2) ベリファイフラグ収得
$ff55   (_COMMON)       (v2) common 領域制御
$ff56   (_RENAME)       (v2) ファイル名変更/移動
$ff57   (_FILEDATE)     (v2) ファイル変更日時収得/設定
$ff58   (_MALLOC2)      (v2) メモリ確保
$ff5a   (_MAKETMP)      (v2) テンポラリファイル作成
$ff5b   (_NEWFILE)      (v2) ファイル作成
$ff5c   (_LOCK)         (v2) ファイルロック
$ff5f   (_ASSIGN)       (v2) 仮想ドライブ/ディレクトリ割り当て収得/設定/解除

$ff60   (_MALLOC3)      (v2) 060turbo メモリ確保
$ff61   (_SETBLOCK2)    (v2) 060turbo メモリブロック変更
$ff62   (_MALLOC4)      (v2) 060turbo メモリ確保
$ff63   (_S_MALLOC2)    (v2) 060turbo メインメモリ管理下メモリブロック確保

$ff7a   (_FFLUSH_SET)   (v2) FFLUSH モードの設定
$ff7b   (_OS_PATCH)     (v2) OS 内部処理切り換え(システム専用コール)
$ff7c   (_GET_FCB_ADR)  (v2) FCB ポインタ収得
$ff7d   (_S_MALLOC)     (v2) メインメモリ管理下メモリブロック確保
$ff7e   (_S_MFREE)      (v2) メインメモリ管理下メモリブロック解放
$ff7f   (_S_PROCESS)    (v2) サブメモリ管理設定

$ff80   _SETPDB         管理プロセス変更
$ff81   _GETPDB         プロセス情報収得
$ff82   _SETENV         環境変数設定
$ff83   _GETENV         環境変数収得
$ff84   _VERIFYG        ベリファイフラグ収得
$ff85   _COMMON         common 領域制御
$ff86   _RENAME         ファイル名変更/移動
$ff87   _FILEDATE       ファイル変更日時収得/設定
$ff88   _MALLOC2        メモリ確保
$ff8a   _MAKETMP        テンポラリファイル作成
$ff8b   _NEWFILE        ファイル作成
$ff8c   _LOCK           ファイルロック
$ff8f   _ASSIGN         仮想ドライブ/ディレクトリ割り当て収得/設定/解除

$ff90   _MALLOC3        060turbo メモリ確保
$ff91   _SETBLOCK2      060turbo メモリブロック変更
$ff92   _MALLOC4        060turbo メモリ確保
$ff93   _S_MALLOC2      060turbo メインメモリ管理下メモリブロック確保

$ffaa   _FFLUSH_SET     FFLUSH モードの設定
$ffab   _OS_PATCH       OS 内部処理切り換え(システム専用コール)
$ffac   _GET_FCB_ADR    FCB ポインタ収得
$ffad   _S_MALLOC       メインメモリ管理下メモリブロック確保
$ffae   _S_MFREE        メインメモリ管理下メモリブロック解放
$ffaf   _S_PROCESS      サブメモリ管理設定

$fff0   _EXITVC         (プログラム終了時実行アドレス)
$fff1   _CTRLVC         (CTRL+C アボート時実行アドレス)
$fff2   _ERRJVC         (エラーアボート時実行アドレス)
$fff3   _DISKRED        ブロックデバイス直接入力
$fff4   _DISKWRT        ブロックデバイス直接出力
$fff5   _INDOSFLG       OS ワークポインタ収得
$fff6   _SUPER_JSR      サブルーチンコール
$fff7   _BUS_ERR        バスエラー発生検査
$fff8   _OPEN_PR        バックグラウンドタスク登録
$fff9   _KILL_PR        自己プロセス削除
$fffa   _GET_PR         スレッド管理情報収得
$fffb   _SUSPEND_PR     スレッド強制スリープ
$fffc   _SLEEP_PR       スリープ
$fffd   _SEND_PR        スレッドコマンド/データ送信
$fffe   _TIME_PR        タイマカウンタ値収得
$ffff   _CHANGE_PR      実行権放棄

備考
    　Human68k v2 までで $ff50～$ff7f に配置されていたコールは、v3 以降では
    +$30 されて $ff80～$ffaf に移動された。この一覧では移動前の番号については
    マクロ定義名を ( ) で囲い、概要の頭に (v2) をつけて表している。

==============================================================================

・エラーコード一覧

$ffffffff ( -1)  無効なファンクションコードを実行した
$fffffffe ( -2)  指定したファイルが見つからない
$fffffffd ( -3)  指定したディレクトリが見つからない
$fffffffc ( -4)  オープンしているファイルが多すぎる
$fffffffb ( -5)  ディレクトリやボリュームラベルはアクセスできない
$fffffffa ( -6)  指定したハンドルはオープンされていない
$fffffff9 ( -7)  メモリ管理領域が破壊された
$fffffff8 ( -8)  実行に必要なメモリがない
$fffffff7 ( -9)  無効なメモリ管理ポインタを指定した
$fffffff6 (-10)  不正な環境を指定した
$fffffff5 (-11)  実行ファイルのフォーマットが異常
$fffffff4 (-12)  オープンのアクセスモードが異常
$fffffff3 (-13)  ファイル名の指定に誤りがある
$fffffff2 (-14)  無効なパラメータでコールした
$fffffff1 (-15)  ドライブ指定に誤りがある
$fffffff0 (-16)  カレントディレクトリは削除できない
$ffffffef (-17)  ioctrlできないデバイス
$ffffffee (-18)  これ以上ファイルが見つからない
$ffffffed (-19)  指定のファイルは書き込みできない
$ffffffec (-20)  指定のディレクトリは既に登録されている
$ffffffeb (-21)  ファイルがあるので削除できない
$ffffffea (-22)  ファイルがあるのでリネームできない
$ffffffe9 (-23)  ディスクが一杯でファイルが作れない
$ffffffe8 (-24)  ディレクトリが一杯でファイルが作れない
$ffffffe7 (-25)  指定の位置にはシークできない
$ffffffe6 (-26)  スーパーバイザ状態で再びスーパーバイザモードの指定を行った
$ffffffe5 (-27)  同じスレッド名が存在する
$ffffffe4 (-28)  プロセス間通信のバッファが書き込み禁止状態
$ffffffe3 (-29)  これ以上バックグラウンドプロセスを起動できない
$ffffffe0 (-32)  ロック領域が足りない
$ffffffdf (-33)  ロックされていてアクセスできない
$ffffffde (-34)  指定のドライブはハンドラがオープンされている
$ffffffdd (-35)  シンボリックリンクのネストが16回を超えた(lndrv)
$ffffffb0 (-80)  ファイルが存在する

==============================================================================

==============================================================================

$ff00   _EXIT           プログラムの終了

        プログラムを終了する。オープンしたファイルハンドルはクローズされ、使用
        中のメモリブロックは全て解放される。
        終了コードは 0 となる。

==============================================================================

$ff01   _GETCHAR        キーボードの入力を待つ(エコーあり)

返値    キーコード

        キーの入力を待ち、入力したキーコードを標準出力に出力する。
        入力されたキーが ^C(親プロセスに戻る)、^P(以後の標準出力をプリンタにも
        出力する)、^N(^P 状態をやめる)のいずれであるか調べる。

==============================================================================

$ff02   _PUTCHAR        指定文字コードの表示

引数    CODE.w          1 バイト文字コード

返値    常に 0

        CODE で指定した文字コードを標準出力に出力する。
        表示中に入力されたキーが ^C、^S、^P、^N であるか調べる。

        move    CODE,-(sp)
        DOS     _PUTCHAR
        addq.l  #2,sp

==============================================================================

$ff03   _COMINP         RS-232C 回線から 1 バイト入力

返値    入力した 1 バイト

        RS-232C 回線から 1 バイト入力する(ブレークチェックあり)。

==============================================================================

$ff04   _COMOUT         RS-232C 回線へ 1 バイト出力

引数    CODE.w          1 バイトコード

        CODE で指定した 1 バイトのコードを RS-232C 回線に出力する(ブレークチェ
        ックあり)。

        move    CODE,-(sp)
        DOS     _COMOUT
        addq.l  #2,sp

==============================================================================

$ff05   _PRNOUT         プリンタへ 1 文字出力

引数    CODE.w          1 バイト文字コード

        CODE で指定した 1 文字をプリンタへ出力する(ブレークチェックあり)。
        CODE の上位バイトは 0 でなければならないので、漢字は上位・下位の順で 1
        バイトずつ出力する。

        move    CODE,-(sp)
        DOS     _PRNOUT
        addq.l  #2,sp

==============================================================================

$ff06   _INPOUT         文字入出力

　標準入力(ファイルハンドル 0、通常はキーボード)から1バイトの入力を行うか、ま
たは標準出力(ファイルハンドル 1、通常はテキスト画面)に1バイトの出力を行う。

　引数 CODE により動作モードが切り替わる。CODE は下位バイトのみ有効。
    CODE = $ff …………… 標準入力から入力する
    CODE = $fe …………… 標準入力から先読み入力する
    CODE = それ以外 ……  標準出力に出力する

CODE = $ff …………… 標準入力から入力する
    　標準入力から1バイトの入力を行う(キー入力を行う)。入力がない場合は待たず
    にすぐに終了する。

    引数    CODE.w  動作モード($ff)

    返値    d0.l    入力された文字(d0.l = 0 なら入力なし)

    　2バイト文字は上位バイト、下位バイトの順に1バイトずつ返される。

    　このファンクションコールはキーボードからの入力を想定していると思われ、標
    準入力がリダイレクトされている場合に入力の有無を判別できない。また標準入力
    がローカルドライブ上のファイルにリダイレクトされていて、かつファイルポイン
    タがファイル末尾を指している場合は、エラーではなく d0.l = 0 が返る。

CODE = $fe …………… 標準入力から先読み入力する
    　標準入力から1バイトの先読み入力を行う。入力がない場合は待たずにすぐに終
    了する。入力がある場合はその文字を返すが、データはそのままバッファに残る。

    引数    CODE.w  動作モード($fe)

    返値    d0.l    入力された文字(d0.l = 0 なら入力なし)

    　2バイト文字は上位バイト、下位バイトの順に1バイトずつ返される。

    不具合
        該当環境: Human68k v3.02 (これ以外は未調査)
        　標準入力がNULデバイスにリダイレクトされている場合、不定な値が返る。
        　標準入力がローカルドライブ上のファイルにリダイレクトされている場合、
        ファイルポインタの位置に関係なく、常に d0.l = $20 が返る。

CODE = それ以外 ……  標準出力に出力する
    　標準出力に1バイトの出力を行う。

    引数    CODE.w  文字コード(1バイト)

    返値    d0.l = 0

    　2バイト文字は上位バイト、下位バイトの順に1バイトずつ出力する。

コード例
    move CODE,-(sp)
    DOS _INPOUT
    addq.l #2,sp

==============================================================================

$ff07   _INKEY          キーボードから 1 文字入力(ブレークチェックなし)

返値    キーコード

        キーが押されるまで待ち、そのキーコードを返す。

==============================================================================

$ff08   _GETC           キーボードから 1 文字入力(ブレークチェックあり)

返値    キーコード

        キーが押されるまで待ち、そのキーコードを返す。^C、^P、^N について調べ
        る。

==============================================================================

$ff09   _PRINT          文字列の表示

引数    MESPTR.l        文字列のポインタ

返値    常に 0

        MESPTR で指定した文字列を表示する。^C、^S、^P、^N について調べる。

        pea     (MESPTR)
        DOS     _PRINT
        addq,l  #4,sp

==============================================================================

$ff0a   _GETS           文字列の入力

引数    INPPTR.l    入力バッファのポインタ

返値    d0.l    入力文字数

    　INPPTR で指定した入力バッファに、改行までの入力文字列を書き込む。改行文
    字はヌル文字に置き換えられる。^C、^P、^N について調べる。最大入力文字数を
    超えた場合は、警告を出すが終了はしない。

    　入力バッファの内容は以下の通りで、最大入力文字数を設定してから呼び出す。
    同一バッファで続けて実行する場合、前回の実行時に得られた入力文字数をクリア
    しないでおけばテンプレート機能が使用できる。

        offset  size
        0       1.b     最大入力文字数 : n
        1       1.b     実際に入力された文字数
        2       n+1.b   入力文字列

コード例
    pea (INPPTR)
    DOS _GETS
    addq.l #4,sp

==============================================================================

$ff0b   _KEYSNS         キーの入力状態の検査

返値    入力状態(0:入力なし、-1:入力あり)

        キーの入力状態を調べる。^C、^P、^N について調べる。

==============================================================================

$ff0c   _KFLUSH         バッファフラッシュ後キーボードから入力

引数    MODE.w          モード
        CODE.w          処理を撰択するコード
        BUFFER.l        入力バッファのポインタ

返値    MODE = 1,7,8
                        入力されたキーコード
        MODE = 6
                CODE = $fe,$ff
                        入力されたキーコード(0 なら入力なし)
                CODE = その他
                        d0.l = 0
        MODE = 10
                        入力文字数

        キー入力バッファを空にしてから、キーボードから入力する。
        MODE の値は DOS コールの下位 1 バイトに対応し、以下の動作をする。

        MODE = 1
                キー入力を待ち、入力されたコードを標準出力に出力する。
        MODE = 6
                CODE = $ff      キー入力(入力がなくても待たない)を調べる。
                CODE = $fe      キーの先読み入力を行う。
                CODE = その他   標準出力に出力する。
        MODE = 7
                キー入力を待つ(ブレークチェックなし)。
        MODE = 8
                キー入力を待つ(ブレークチェックあり)。
        MODE = 10
                改行までに入力した文字列をバッファに書き込む。

MODE = 1,7,8
        move    MODE,-(sp)
        DOS     _KFLUSH
        addq.l  #2,sp

MODE = 6
        move    CODE,-(sp)
        move    MODE,-(sp)
        DOS     _KFLUSH
        addq.l  #4,sp

MODE = 10
        pea     (BUFFER)
        move    MODE,-(sp)
        DOS     _KFLUSH
        addq.l  #6,sp

==============================================================================

$ff0d   _FFLUSH         ディスクのリセット

返値    常に 0

        ディスクバッファの内容と標準入力からの行入力バッファを初期化する。ファ
        イルのクローズはしない。fflush = off であれば何もしない。

==============================================================================

$ff0e   _CHGDRV         カレントドライブの設定

引数    DRIVE.w         ドライブ番号(0:A 1:B … 25:Z)

返値    指定可能ドライブ数(1～26)

        カレントドライブを変更する。返値が指定したドライブ番号以下であれば失敗
        したことになる。

        move    DRIVE,-(sp)
        DOS     _CHGDRV
        addq.l  #2,sp

==============================================================================

$ff0f   _DRVCTRL        ドライブの状態検査/設定

引数    MODE.w          (MD.b×256＋DRIVE.b)
                MB.b            モード
                DRIVE.b         ドライブ番号(0:カレント 1:A 2:B … 26:Z)
        P1.l            引数 1
        P2.l            引数 2
        …
        Pn.l            引数 n

返値    MD = 0
                指定ドライブの状態

                        bit 7   LED 点滅
                        bit 6   イジェクト禁止
                        bit 5   バッファあり
                        bit 4   ユーザーによるイジェクト禁止
                        bit 3   PRO(プロテクト = 1)
                        bit 2   RDY(ノットレディ = 1)
                        bit 1   メディア挿入
                        bit 0   誤挿入

                注: PRO と RDY はメディアが挿入されていた場合のみ返す。

        モード MD の値に従って、ドライブ番号 DRIVE で指定したドライブの状態を
        検査/設定する。
        MODE の上位 8bit にモード MD、下位 8bit にドライブ番号 DRIVE を指定す
        る。

        MD = 0          状態検査。
        MD = 1          排出(オープン中のファイルがあるとエラー)。
        MD = 2          排出禁止(MD = 1 の排出も禁止)。
        MD = 3          排出許可(オープンされているドライブはクローズされず、
                        バッファは自動的に消去される)。
        MD = 4          ディスク未挿入時に LED 点滅。
        MD = 5～8       使用禁止。
        MD = 9          カレントディレクトリをルートにして検索 FAT を先頭に戻
                        す(オープンされているファイルがあるとエラー)。
        MD = 10         検索 FAT を先頭に戻す。
        MD = 11～15     予約。
        MD = 16～       特殊ブロックデバイスに対して使用する(任意の引数が追加
                        可能)。

MD = 0～4,9,10
        move    MODE,-(sp)
        DOS     _DRVCTRL
        addq.l  #2,sp

MD = 16～
        move.l  Pn,-(sp)
        …
        move.l  P1,-(sp)
        move    MODE,-(sp)
        DOS     _DRVCTRL
        lea     (n*4+2,sp),sp

==============================================================================

$ff10   _CONSNS         画面出力ができるかの検査

返値    出力状態(0:出力不可、0 以外:出力可能)

        画面に出力可能か調べる。

==============================================================================

$ff11   _PRNSNS         プリンタ出力ができるかの検査

返値    出力状態(0:出力不可、0 以外:出力可能)

        プリンタに出力可能か調べる。

==============================================================================

$ff12   _CINSNS         RS-232C 回線から入力ができるかの検査

返値    入力状態(0:入力不可、0 以外:入力可能)

        RS-232C 回線から入力可能か調べる。

==============================================================================

$ff13   _COUTSNS        RS-232C 回線へ出力ができるかの検査

返値    出力状態(0:出力不可、0 以外:出力可能)

        RS-232C 回線に出力可能か調べる。

==============================================================================

$ff17   _FATCHK         ドライブのセクタが連続しているかの検査

　指定したファイル名のドライブ番号とセクタの連結状態(セクタ番号と連続するセク
タ数)を調べ、バッファに書き込む。この DOS コールで FAT が連続しているかどうか
を調べたり、得られたセクタ番号を使って DOS _DISKRED でデータ部を直接読むことが
できる。

　バッファアドレスの引数 BUFFER により動作モードが切り替わる。
    BUFFER = アドレス  …………………… [1] (ワードモード)
    BUFFER = アドレス + $8000_0000 …… [2] (ロングワードモード)

BUFFER = アドレス …… [1] (ワードモード)
    　セクタ番号とセクタ数をワードサイズで書き込む。

    引数    FILE.l      ファイル名のポインタ
            BUFFER.l    バッファのポインタ

    返値    d0.l    バッファの使用バイト数(負数ならエラーコード)
                    FAT が完全に連続している場合は d0.l = 8 となる。

    　バッファのバイト数は指定できず65536バイトとして扱われるので、十分な容量
    を用意しておくこと。

    　セクタ番号やセクタ数が $ffff を超える(ワードサイズで表現できない)場合は
    代わりに $ffff がバッファに書き込まれる。この場合 DOS _DISKRED でデータ部
    部を正しく読み込むことができない。

    　バッファに書き込まれるデータは以下の構造。
        offset  size
        0       1.w     ドライブ番号    : d(1:A 2:B … 26:Z)
        2       1.w     先頭セクタ番号  : s1
        4       1.w     セクタ数        : n1
        6       1.w     次のセクタ番号  : s2
        8       1.w     セクタ数        : n2
                …
        ?       1.w     終わり          : 0

    コード例
        pea (BUFFER)
        pea (FILE)
        DOS _FATCHK
        addq.l #8,sp

BUFFER = アドレス＋$8000_0000 [2] (ロングワードモード)
    　セクタ番号とセクタ数をロングワードサイズで書き込む。

    引数    FILE.l      ファイル名のポインタ
            BUFFER.l    バッファのポインタ
            LEN.w       バッファのバイト数

    返値    d0.l    バッファの使用バイト数(負数ならエラーコード)
                    FAT が完全に連続している場合は d0.l = 14 となる。

    　BUFFER & $00ff_ffff の値がバッファアドレスとして使用される。060turbo.sys
    組み込み時は BUFFER & $1fff_ffff の値が使用される。

    　バッファに書き込まれるデータは以下の構造。
        offset  size
        0       1.w     ドライブ番号    : d(1:A 2:B … 26:Z)
        2       1.l     先頭セクタ番号  : s1
        6       1.l     セクタ数        : n1
        10      1.l     次のセクタ番号  : s2
        14      1.l     セクタ数        : n2
                …
        ?       1.l     終わり          : 0

    不具合
        該当環境: Human68k v3.02 (これ以外は未調査)
        　LEN≧2のとき、バッファ末尾を最大4バイト越えてデータを書き込むことが
        ある。

    コード例
        move #LEN,-(sp)
        pea (BUFFER+$8000_0000)
        pea (FILE)
        DOS _FATCHK
        lea (10,sp),sp

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

==============================================================================

$ff18   _HENDSP         漢字変換行の制御

引数    MD.w            コントロールモード
        POS.w           ポジション(変換ウィンドウの先頭からの位置)
        MESPTR.l        変換文字列のポインタ

返値    MD = 0,4,8
                ウィンドウの最大文字数
        MD = 1,2,5,6,7,10
                次のポジション

        モード MD の値に従って漢字変換行を制御する。
        この DOS コールは漢字変換を扱うプログラムに使用するが、日本語 FP から
        利用するので一般のアプリケーションは使用禁止。

        MD = 0
                モード表示ウィンドウをオープンする。
        MD = 1
                指定位置から文字列をノーマルで表示する。
        MD = 2
                指定位置から文字列をリバースで表示する。
        MD = 3
                モード表示ウィンドウをクローズする。
        MD = 4
                入力ウィンドウをオープンする。
        MD = 5
                指定位置から文字列をノーマルで表示する。
        MD = 6
                指定位置から文字列をリバースで表示する。
        MD = 7
                指定のポジション以降を元に戻す。
        MD = 8
                侯補ウィンドウをオープンする。
        MD = 9
                指定位置から文字列をノーマルで表示する。
        MD = 10
                指定位置から文字列をリバースで表示する。
        MD = 11
                侯補ウィンドウをクローズする。

MD = 0,3,4,8,11
        move    MD,-(sp)
        DOS     _HENDSP
        addq.l  #2,sp

MD = 7
        move    POS,-(sp)
        move    MD,-(sp)
        DOS     _HENDSP
        addq.l  #4,sp

MD = 1,2,5,6,9,10
        pea     (MESPTR)
        move    POS,-(sp)
        move    MD,-(sp)
        DOS     _HENDSP
        addq.l  #8,sp

==============================================================================

$ff19   _CURDRV         カレントドライブを得る

返値    カレントドライブの番号(0:A 1:B … 25:Z)

        カレントドライブの値を調べる。

==============================================================================

$ff1a   _GETSS          文字列の入力

引数    INPPTR.l    入力バッファのポインタ

返値    d0.l    入力文字数

    　INPPTR で指定した入力バッファに、改行までの入力文字列を書き込む。改行文
    字はヌル文字に置き換えられる。ブレークチェックはしない(VOID/NEWLINE で改行
    しない)。最大入力文字数を超えた場合は、警告を出すが終了はしない。

    　入力バッファの内容は以下の通り。

        offset  size
        0       1.b     最大入力文字数 : n
        1       1.b     (実際に入力された文字数)
        2       n+1.b   入力文字列

コード例
    pea (INPPTR)
    DOS _GETSS
    addq.l #4,sp

==============================================================================

$ff1b   _FGETC          ファイルハンドルから 1 バイト入力

引数    FILENO.w        ファイルハンドル

返値    入力した 1 バイトコード

        FILENO で指定したファイルハンドルから入力があるまで待ち、入力があった
        らそのコードを返す。

==============================================================================

$ff1c   _FGETS          ファイルハンドルから文字列入力

引数    BUFFER.l        入力バッファのポインタ
        FILENO.w        ファイルハンドル

返値    入力文字数

        FILENO で指定したファイルハンドルから改行までの文字列を入力し、BUFFER
        で指定した入力バッファに書き込む。改行文字はヌル文字に置き換えられる。
        ブレークチェックはしない(VOID/NEWLINE で改行しない)。
        最大入力文字数を超えた場合は、最大入力文字数まで入れて終了する。
        入力バッファの内容は以下の通り。

offset  size
0       1.b     最大入力文字数  : n
1       1.b     (実際に入力された文字数)
2       n+1.b   入力文字列

        move    FILENO,-(sp)
        pea     (BUFFER)
        DOS     _FGETS
        addq.l  #6,sp

==============================================================================

$ff1d   _FPUTC          ファイルハンドルに 1 バイト出力

引数    CODE.w          1 バイトコード
        FILENO.w        ファイルハンドル

        CODE で指定した 1 バイトコードを、FILENO で指定したファイルハンドルに
        出力する。

        move    FILENO,-(sp)
        move    CODE,-(sp)
        DOS     _FPUTC
        addq.l  #4,sp

==============================================================================

$ff1e   _FPUTS          ファイルハンドルに文字列出力

引数    MESPTR.l        文字列のポインタ
        FILENO.w        ファイルハンドル

        MESPTR で指定した文字列を、FILENO で指定したファイルハンドルに出力する。
        文字列の末尾のヌル文字は出力しない。

        move    FILENO,-(sp)
        pea     (MESPTR)
        DOS     _FPUTS
        addq.l  #6,sp

==============================================================================

$ff1f   _ALLCLOSE       全ファイルのクローズ

        オープンしたファイルを全てクローズする。

==============================================================================

$ff20   _SUPER          スーパーバイザ/ユーザーモードの切り替え

引数    STACK.l         切り替えモード(0 若しくは SSP に設定するアドレス)

返値    STACK = 0
                前の SSP の値(負数ならエラーコード)

        切り替えモード STACK の値に従って、スーパーバイザ/ユーザーモードを切り
        替える。

        STACK = 0
                USP の値を SSP に設定し、スーパーバイザモードに切り替える。
        STACK = その他
                STACK を SSP に設定し、ユーザーモードに切り替える。

        pea     (STACK)
        DOS     _SUPER
        addq.l  #4,sp

==============================================================================

$ff21   _FNCKEY         再定義可能なキーの読み出し/設定

引数    MODE.w          モード及びキー番号(MD.b×256＋FNO.b)
        BUFFER.l        データバッファのポインタ

返値    d0.l =  0       正常終了
                -1      キー番号が異常

        モード MD の値によって、再定義可能なキーの収得/設定をする。
        この DOS コールは、CON デバイス(コンソール)でサポートされる。
        MODE の上位 8bit にモード MD、下位 8bit にキー番号 FNO を指定する。

        MD = 0  収得
        MD = 1  設定(同時にファンクションキーの表示も行なうが、32 行モードの時
                は表示しない)

        FNO     キー名
         0      全てのキー
         1～10  F01～F10
        11～20  SHIFT＋F01～F10
        21      ROLL UP
        22      ROLL DOWN
        23      INS
        24      DEL
        25      UP(↑)
        26      LEFT(←)
        27      RIGHT(→)
        28      DOWN(↓)
        29      CLR
        30      HELP
        31      HOME
        32      UNDO

        BUFFER は収得/設定のためのバッファで、大きさは FNO の値によって異なる。

        FNO =  0        712 バイト(32×20＋6×12 バイト)
        FNO =  1～20     32 バイト(31 バイト＋$00)
        FNO = 21～32      6 バイト( 5 バイト＋$00)

        pea     (BUFFER)
        move    MODE,-(sp)
        DOS     _FNCKEY
        addq.l  #6,sp

==============================================================================

$ff22   _KNJCTRL        仮名漢字変換用ファンクションコールの呼び出し

        この DOS コールは、日本語 FP のファンクションコールで使用する。

==============================================================================

$ff23   _CONCTRL        コンソールの制御/直接出力

引数    MD.w            コントロールモード(この値によって引数が異なる)
        CODE.w          1 バイトコード
        MESPTR.l        文字列のポインタ
        ATR.w           文字属性
        X.w             カーソル位置指定
        Y.w             カーソル位置指定
        N.w             カーソル相対移動指定
        MOD.w           画面制御指定
        YS.w            スクロール範囲指定
        YL.w            スクロール範囲指定

返値    MD = 0～1
                表示後のカーソル位置
                d0.hw   桁位置
                d0.w    行〃
        MD = 2
                変更前の文字属性(-1 ならエラー)
        MD = 3
                変更前のカーソル位置(-1 ならエラー)
                d0.hw   桁位置
                d0.w    行〃
        MD = 4～5、7～9、12～13
                常に 0
        MD = 6
                d0.l =  0       正常終了
                d0.l = -1       エラー(移動できない)
        MD = 10、17～18
                不定
        MD = 11
                d0.l =  0       正常終了
                d0.l = -1       エラー(モードが不正若しくはカーソル位置が不正)
                                ROM IOCS version 1.3 未満で後者の原因でエラー
                                になった場合、-1 以外の負数になることがある。
        MD = 14、16
                変更前のモード
        MD = 15
                d0.l =  0       正常終了
                d0.l = -1       エラー(範囲指定が不正)

        コントロールコード MD の値に従って、コンソールから直接入力/制御を行う。
        この DOS コールは CON デバイスでサポートされる。

        MD = 0
                CODE で指定した 1 バイトコードを表示する(IOCS _B_PUTC)。
        MD = 1
                MESPTR で指定した文字列を表示する(IOCS _B_PRINT)。
        MD = 2
                ATR で指定した文字属性を設定する(IOCS _B_COLOR)。ATR = -1 の時
                は現在の文字属性を収得する。
        MD = 3
                カーソルを X、Y で指定した位置に設定する(IOCS _B_LOCATE)。X =
                -1 の時は現在のカーソル位置を収得する。
        MD = 4
                カーソルを 1 行下に移動する。最下行でスクロールアップする
                (IOCS _B_DOWN_S)。
        MD = 5
                カーソルを 1 行上に移動する。先頭行でスクロールダウンする
                (IOCS _B_UP_S)。
        MD = 6
                カーソルを N 行上に移動する。移動できない時はエラーになる
                (IOCS _B_UP)。
        MD = 7
                カーソルを N 行下に移動する。移動できない時は最下行まで移動す
                る(IOCS _B_DOWN)。
        MD = 8
                カーソルを N 桁右に移動する。移動できない時は右端まで移動する
                (IOCS _B_RIGHT)。
        MD = 9
                カーソルを N 桁左に移動する。移動できない時は左端まで移動する
                (IOCS _B_LEFT)。
        MD = 10
                モード MOD の値に従って、画面を消去する(IOCS _B_CLR_ST)。

                MOD = 0         カーソル位置から最終行右端まで
                MOD = 1         先頭行左端からカーソル位置まで
                MOD = 2         画面全体(カーソルは先頭行左端に移動する)
        MD = 11
                モード MOD の値に従って、現在行を消去する(IOCS _ERA_ST)。

                MOD = 0         カーソル位置から行の右端まで
                MOD = 1         行の左端からカーソル位置まで
                MOD = 2         カーソル行全体
        MD = 12
                カーソル行に N 行挿入する(IOCS _B_INS)。
        MD = 13
                カーソル行から N 行削除する(IOCS _B_DEL)。
        MD = 14
                モード MOD の値に従って、ファンクションキー行のモードを設定し、
                前のモードを返す。スクロール範囲はリセットされる。

                MOD =  0        ファンクションキーを表示(スクロール範囲は 0 か
                                ら 31 行分)
                MOD =  1        シフトファンクションキーを表示(同上)
                MOD =  2        何も表示しない(同上)
                MOD =  3        何も表示しない(スクロール範囲は 0 から 32 行分)
                MOD = -1        現在のモードを調べる
        MD = 15
                YS、YL でスクロール範囲を設定する。
                スクロール後、カーソルは先頭行左端に移動する。
                YS＋YL の値は、ファンクションキー行のモードが 3 の時は 32 まで、
                それ以外は 31 までの範囲で指定する。
                絶対座標の (0,YS) が 論理座標の (0,0) となる。
        MD = 16
                モード MOD に従って画面モードを設定し、前のモードを返す。
                IOCS _TGUSEMD でグラフィック画面を使用中に設定していても、MOD
                = 1、3～5 がエラーにならずに画面モードを変更してしまうので注意
                すること。

                MOD     表示画面        グラフィック
                0       768×512     なし
                1       768×512    16 色
                2       512×512     なし
                3       512×512    16 色
                4       512×512   256 色
                5       512×512 65536 色
                -1      現在のモードを調べる。
        MD = 17
                カーソルを表示するモードにする(IOCS _OS_CURON)。
        MD = 18
                カーソルを表示しないモードにする(IOCS _OS_CUROF)。

        MD = 6～9、12～13 で N = 0 を指定した場合は N = 1 として扱われる。

MD = 0
        move    CODE,-(sp)
        move    MD,-(sp)
        DOS     _CONCTRL
        addq.l  #4,sp

MD = 1
        pea     (MESPTR)
        move    MD,-(sp)
        DOS     _CONCTRL
        addq.l  #6,sp

MD = 2
        move    ATR,-(sp)
        move    MD,-(sp)
        DOS     _CONCTRL
        addq.l  #4,sp

MD = 3
        move    Y,-(sp)
        move    X,-(sp)
        move    MD,-(sp)
        DOS     _CONCTRL
        addq.l  #6,sp

MD = 4,5,17,18
        move    MD,-(sp)
        DOS     _CONCTRL
        addq.l  #2,sp

MD = 6～9,12～13
        move    N,-(sp)
        move    MD,-(sp)
        DOS     _CONCTRL
        addq.l  #4,sp

MD = 10,11,14,16
        move    MOD,-(sp)
        move    MD,-(sp)
        DOS     _CONCTRL
        addq.l  #4,sp

MD = 15
        move    YL,-(sp)
        move    YS,-(sp)
        move    MD,-(sp)
        DOS     _CONCTRL
        addq.l  #6,sp

==============================================================================

$ff24   _KEYCTRL        コンソールの状態検査/直接入力

引数    MD.w            コントロールモード(この値によって引数が異なる)
        GROUP.w         キーコードグループ
        INSMODE.w       INS キーのモード(-1:ON 0:OFF)

返値    MD = 0、1
                入力されたキーコード
        MD = 2
                シフトキーの状態(ビット 10～4 は 1 の時 LED 点灯、ビット 3～0
                は 1 の時キーが押されている)
                        bit 10  全角
                        bit  9  ひらがな
                        bit  8  INS
                        bit  7  CAPS
                        bit  6  コード入力
                        bit  5  ローマ字
                        bit  4  かな
                        bit  3  OPT.2
                        bit  2  OPT.1
                        bit  1  CTRL
                        bit  0  SHIFT
        MD = 3
                キーの状態
        MD = 4
                常に 0

        コントロールコード MD の値に従って、直接コンソールから入力/状態検査を
        行う。
        この DOS コールは CON デバイスでサポートされる。

        MD = 0
                キーを入力する。
                Human68k version 3.02 では入力がない場合に入力待ちをしないが、
                ASK68K 組み込み時は入力待ちをする(Human68k の他のバージョンは
                未調査)。
        MD = 1
                キーコードを先読みする。
        MD = 2
                シフトキーの状態を調べる。
        MD = 3
                GROUP で指定したキーコードグループのキー状態を調べる。
        MD = 4
                INS キーを ON/OFF する。

MD = 0～2
        move    MD,-(sp)
        DOS     _KEYCTRL
        addq.l  #2,sp

MD = 3
        move    GROUP,-(sp)
        move    MD,-(sp)
        DOS     _KEYCTRL
        addq.l  #4,sp

MD = 4
        move    INSMODE,-(sp)
        move    MD,-(sp)
        DOS     _KEYCTRL
        addq.l  #4,sp

==============================================================================

$ff25   _INTVCS         ベクタの処理アドレスの設定

引数    INTNO.w         ベクタ番号
        JOBADR.l        指定ベクタの処理アドレス

返値    指定ベクタの前の処理アドレス

        ベクタ番号 INTNO で指定するベクタに JOBADR を設定し、以前の設定アドレ
        スを返す。

        INTNO = $0000～$00ff    割り込み
        INTNO = $0100～$01ff    IOCS コール
        INTNO = $ff00～$ffff     DOS コール

        trap #10～14 及び _EXITVC のアドレスを変更した場合、PSP 内のワークも変
        更される。また、_ERRJVC では更にアボート時の sr、ssp をこの DOS コール
        が実行された瞬間のものに変更する。_CTRLVC の場合は _CTRLVC のアドレス
        と PSP 内のワークを変更した後、更に _ERRJVC と同じ処理を行う。

        pea     (JOBADR)
        move    INTNO,-(sp)
        DOS     _INTVCS
        addq.l  #6,sp

==============================================================================

$ff26   _PSPSET         プロセス管理ポインタの作成

引数    PSPADR.l        プロセス管理ポインタのアドレス(メモリ管理ポインタ+16)

返値    常に 0

        PSPADR で指定したアドレスに、プログラム終了時の様々な情報を作成する。
        プロセス管理ポインタ PSPADR はメモリ管理ポインタ＋$10 のアドレスでなく
        てはならず、その大きさは 240 バイト。

        pea     (PSPADR)
        DOS     _PSPSET
        addq.l  #4,sp

==============================================================================

$ff27   _GETTIM2        時刻を得る(ロングワード)

返値    現在の時刻

                %0000_0000_000t_tttt_00mm_mmmm_00ss_ssss
                bit 20～16      時(0～23 時)
                bit 13～ 8      分(0～59 分)
                bit  5～ 0      秒(0～59 秒)

        現在の時刻を調べる。DOS _GETTIME との違いは、秒が 1 秒単位なので返値が
        ロングワードになっていることである。

==============================================================================

$ff28   _SETTIM2        時刻の設定(ロングワード)

引数    TIME.l          時刻(形式は DOS _GETTIM2 の返値と同じ)

返値    エラーコード

        時刻を TIME の値に設定する。DOS _SETTIME との違いは、秒が 1 秒単位なの
        で TIME がロングワードになっていることである。

        move.l  TIME,-(sp)
        DOS     _SETTIM2
        addq.l  #4,sp

==============================================================================

$ff29   _NAMESTS        ファイル名の展開

引数    FILE.l          ファイル名のポインタ
        BUFFER.l        バッファのポインタ

返値    d0.l    エラーコード

    　FILE で指定したファイル名を、BUFFER で指定した88バイトのバッファに展開す
    る。FILE が空文字列の場合はカレントディレクトリが指定されたものとして扱わ
    れる。

offset  size
 0       1.b    flg     ワイルドカードの文字数
                            0: ワイルドカードなし
                          1～: ワイルドカードあり
                          $ff: ファイル指定なし(ディレクトリ指定)
 1       1.b    drive   ドライブ番号(A=0,B=1,…,Z=25)
 2      65.b    path    パス名('\'＋あればサブディレクトリ名＋'\')
67       8.b    name1   ファイル名1(先頭8バイト、余白は $20)
75       3.b    ext     拡張子(余白は $20)
78      10.b    name2   ファイル名2(残りの10バイト、余白は $00)

    　パス名についてはディレクトリ名の長さ(最大22文字)の検査は行われない。また
    ワイルドカード('*'と'?')はエラーにならず、'*'から'?'への展開も行われない。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    　指定したファイル名のパス名部分とカレントディレクトリの結合結果が長すぎる
    場合、バッファ末尾を超えてデータを書き込むことがある。

コード例
    pea (BUFFER)
    pea (FILE)
    DOS _NAMESTS
    addq.l #8,sp

==============================================================================

$ff2a   _GETDATE        日付を得る

返値    現在の日付

                %0000_0000_0000_0www_yyyy_yyym_mmmd_dddd
                bit 18～16      曜日(0～6)
                bit 15～ 9      年-1980(0～99)
                bit  8～ 5      月(1～12 月)
                bit  4～ 0      日(1～31 日)

        現在の日付を調べる。曜日は 0～6 が日～土曜日を表し、年は西暦から 1980
        を引いた値が 0～99 まで設定されている。

==============================================================================

$ff2b   _SETDATE        日付の設定

引数    DATE.w          日付

返値    エラーコード

        DATE の値を日付に設定する。DATE の形式は以下の通りで、年は西暦から
        1980 を引いた値を 0～99 まで設定する。

        %yyyy_yyym_mmmd_dddd
        bit 15～ 9      年-1980(0～99)
        bit  8～ 5      月(1～12 月)
        bit  4～ 0      日(1～31 日)

        move    DATE,-(sp)
        DOS     _SETDATE
        addq.l  #2,sp

==============================================================================

$ff2c   _GETTIME        時刻を得る

返値    現在の時刻(下位ワードのみ意味がある)

                %tttt_tmmm_mmms_ssss
                bit 15～11      時  (0～23 時)
                bit 10～ 5      分  (0～59 分)
                bit  4～ 0      秒/2(0～29 秒)

        現在の時刻を調べる。返値のうち秒は 2 秒単位で表し、実際の秒を 2 で割っ
        た値になる。DOS _GETTIM2 との違いは、秒が 2 秒単位なので返値がワードに
        なっていることである。

==============================================================================

$ff2d   _SETTIME        時刻の設定

引数    TIME.w          時刻(形式は DOS _GETTIME の返値と同じ)

返値    エラーコード

        時刻を TIME の値に設定する。このうち秒は 2 秒単位で表し、実際の秒を 2
        で割った値になる。したがって、設定する値は 0～29 まで。DOS _SETTIM2 と
        の違いは、秒が 2 秒単位なので TIME がワードになっていることである。

        move    TIME,-(sp)
        DOS     _SETTIME
        addq.l  #2,sp

==============================================================================

$ff2e   _VERIFY         ベリファイフラグの設定

引数    FLG.w           ベリファイフラグ(0:ベリファイしない 1:する)

        ベリファイフラグを設定する。

        move    FLG,-(sp)
        DOS     _VERIFY
        addq.l  #2,sp

==============================================================================

$ff2f   _DUP0           ファイルハンドルの強制複写

引数    FILENO.w        ファイルハンドル
        NEWNO.w         複写先のファイルハンドル

返値    NEWNO の前の値(負数ならエラーコード)

        ファイルハンドル FILENO を、2 個目の ファイルハンドル NEWNO に強制複写
        する。これにより 1 個のファイルに 2 個のファイルハンドルが与えられ、同
        一ファイルの操作を複数のファイルハンドルで行うことが出来るようになる。
        クローズすると元の番号に戻る。
        指定できる NEWNO は 0～4(標準ファイルハンドル)だけで、それより大きい数
        のハンドルの場合は DUP2 で指定する。

        move    NEWNO,-(sp)
        move    FILENO,-(sp)
        DOS     _DUP0
        addq.l  #4,sp

==============================================================================

$ff30   _VERNUM         OS のバージョン検査

返値    バージョン番号

                bit 31～24      '6'($36)
                bit 23～16      '8'($38)
                bit 15～ 8      バージョン番号の整数部
                bit  7～ 0      バージョン番号の小数部

        Human68k のバージョン番号を調べる。version 3.02 なら d0.l = $36380302
        のようになる。

==============================================================================

$ff31   _KEEPPR         常駐終了

引数    PRGLEN.l        常駐バイト数
        CODE.w          終了コード

        PRGLEN バイト(PSP 部分を含まない)を残して、プロセスを終了する。指定さ
        れたバイト数が確保できない場合は現在のメモリブロックの大きさのまま常駐
        終了する。オープンしたファイルハンドルはクローズされず、使用中のメモリ
        ブロックも解放されないので注意すること。
        実際にメモリに常駐するサイズは、指定した常駐バイト数＋メモリ管理ポイン
        タ 16 バイト＋プロセス管理ポインタ 240 バイトとなる。
        終了コードは CODE で指定した値の上位ワードが 1 となった値($0001_xxxx)
        となる(_EXIT 及び _EXIT2 は $0000_xxxx)。

        move    CODE,-(sp)
        move.l  PRGLEN,-(sp)
        DOS     _KEEPPR

==============================================================================

$ff32   _GETDPB         ドライブパラメータブロックの複写

引数    DRIVE.w         ドライブ番号(0:カレント 1:A 2:B … 26:Z)
        DPBPTR.l        バッファのポインタ

返値    エラーコード

    　DRIVE で指定したドライブのドライブパラメータブロックを、Human68k version
    1 互換の形式に変換して、DPBPTR で指定した 94 バイトのバッファに複写する。

    　Human68k version 1 互換形式 DPB の内容は以下の通り。

offset  size
 0      1.b     ドライブ番号(0:A 1:B … 25:Z)
 1      1.b     デバイスドライバで使うユニット番号
 2      1.w     1 セクタ当りのバイト数
 4      1.b     1 クラスタ当りのセクタ数-1
 5      1.b     クラスタ→セクタのシフト数
                bit 7 = 1 で MS-DOS 形式 FAT(16bit Intel 配列)
 6      1.w     FAT の先頭セクタ番号
 8      1.b     FAT 領域の個数
 9      1.b     FAT の占めるセクタ数(複写分を除く)
10      1.w     ルートディレクトリに入るファイルの個数
12      1.w     データ領域の先頭セクタ番号
14      1.w     総クラスタ数+1
16      1.w     ルートディレクトリの先頭セクタ番号
18      1.l     デバイスドライバへのポインタ
22      1.b     メディアバイト
                リモートドライブの場合は小文字の物理ドライブ名('a'～'z')
23      1.b     DPB 使用フラグ(-1 なら書き込みが行われた)
                リモートドライブの場合は常に 0
24      1.l     次の DPB へのポインタ(-1 で末尾)
28      1.w     カレントディレクトリのクラスタ番号(0 はルートを表す)
                リモートドライブの場合は常に 0
30      64.b    カレントディレクトリの文字バッファ

ユーザー拡張
    　リモートドライブのメディアバイトについては、(V)TwentyOne.sys を組み込み、
    かつ対応したデバイスドライバを使うことで任意の値を返すことができる。

コード例
    pea (DPBPTR)
    move DRIVE,-(sp)
    DOS _GETDPB
    addq.l #6,sp

==============================================================================

$ff33   _BREAKCK        ブレークチェックの設定

引数    FLG.w           機能及びモード(FUNC.b×256+MODE.b)
                        FLG = -1 の場合は FUNC = 0 と同じ。

返値    設定状況(MODE の 0～2 と同じ)

        フラグ FLG の値に従って、ブレークチェックを設定する。
        返値は今設定した値そのものであるので注意すること。

        FUNC =  0       DOS コールでのブレークチェックを設定する
                MODE =  0       指定の DOS コールのみ検査する
                        1       全ての DOS コールで検査する
                        2       全ての DOS コールで検査しない
                        -1      設定状況を調べる

        指定の DOS コールとは、ブレークチェックをする以下のコールを指す。

        $ff01   GETCHAR
        $ff02   PUTCHAR
        $ff03   COMINP
        $ff04   COMOUT
        $ff05   PRNOUT
        $ff08   GETC
        $ff09   PRINT
        $ff0a   GETS
        $ff0b   KEYSNS
        $ff0c   KFLUSH
        $ff0d   FFLUSH
        $ff1e   FPUTS

        Human68k version 3.00 以降では下記の機能も使用可能。

        FUNC =  1       CTRL+C のモードを設定する
        FUNC =  2       CTRL+N のモードを設定する
        FUNC =  3       CTRL+P のモードを設定する
        FUNC =  4       CTRL+Q のモードを設定する
        FUNC =  5       CTRL+S のモードを設定する
                それぞれ MODE の内容は以下の通り。
                MODE =  0       無効
                        1       有効
                        -1      設定状況を調べる

        move    #FLG,-(sp)
        DOS     _BREAKCK
        addq.l  #2,sp

==============================================================================

$ff34   _DRVXCHG        ドライブの入れ替え

引数    OLD.w           ドライブ番号(0:カレント 1:A 2:B … 26:Z)
        NEW.w           ドライブ番号(〃)

返値    OLD = -1、NEW = -1
                カレントドライブの新しいドライブ番号(0:A 1:B … 25:Z)
        その他
                エラーコード

        OLD で指定したドライブと、NEW で指定したドライブを入れ替える。
        OLD、NEW ともに -1 を指定すると、全てのドライブ変更を元に戻す。

        move    NEW,-(sp)
        move    OLD,-(sp)
        DOS     _DRVXCHG
        addq.l  #4,sp

==============================================================================

$ff35   _INTVCG         ベクタの処理アドレスを得る

引数    INTNO.w         ベクタ番号

返値    指定ベクタの処理アドレス

        ベクタ番号 INTNO で指定したベクタの処理アドレスを調べる。

        INTNO = $0000～$00ff    割り込み
        INTNO = $0100～$01ff    IOCS コール
        INTNO = $ff00～$ffff     DOS コール

        move    INTNO,-(sp)
        DOS     _INTVCG
        addq.l  #2,sp

==============================================================================

$ff36   _DSKFRE         ディスクの残り容量を得る

引数    DRIVE.w         ドライブ番号
        BUFFER.l        バッファのポインタ

返値    使用可能なバイト数(最大 2GB、負数ならエラーコード)

        DRIVE で指定したドライブのディスクの残り容量を調べ、結果を BUFFER で指
        定した 8 バイトのバッファに書き込む。

offset  size
0       1.w     使用可能なクラスタ数
2       1.w     総クラスタ数
4       1.w     1 クラスタ当りのセクタ数
6       1.w     1 セクタ当りのバイト数

        pea     (BUFFER)
        move    DRIVE,-(sp)
        DOS     _DSKFRE
        addq.l  #6,sp

==============================================================================

$ff37   _NAMECK         ファイル名の展開

引数    FILE.l          ファイル名のポインタ
        BUFFER.l        バッファのポインタ

返値    d0.l = $ff      ファイル指定なし
        d0.l =   0      ワイルドカード指定なし
        d0.l <   0      エラーコード(BUFFER の内容は意味がない)
        d0.l = その他   ワイルドカード指定あり(d0.l はワイルドカードの文字数)

    　FILE で指定したファイルを、BUFFER で指定した 91 バイトのバッファに展開す
    る。FILE が空文字列の場合はカレントディレクトリが指定されたものとして扱わ
    れる。

offset  size
 0       2.b    drive  ドライブ名('A:'～'Z:')
 2      65.b    path   パス名(最大64バイト)＋0
67      19.b    name   ファイル名(最大18バイト)＋0
86       5.b    ext    '.'＋拡張子(最大3バイト)＋0
                         拡張子がない場合は0

    　パス名についてはディレクトリ名の長さ(最大22文字)の検査は行われない。また
    ワイルドカード('*'と'?')はエラーにならず、'*'から'?'への展開も行われない。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているため、同様にバッファ末尾を超
    えてデータを書き込むことがある。

コード例
    pea (BUFFER)
    pea (FILE)
    DOS _NAMECK
    addq.l #8,sp

==============================================================================

$ff39   _MKDIR          サブディレクトリの作成

引数    FILE.l      ディレクトリ名のポインタ

返値    d0.l    エラーコード

    　FILE で指定したサブディレクトリを作成する。

    　成功した際の返値は通常 d0.l = 0 だが、特殊デバイスドライバが対象の場合は
    正の整数が返ることがある。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

コード例
    pea (FILE)
    DOS _MKDIR
    addq.l #4,sp

==============================================================================

$ff3a   _RMDIR          サブディレクトリの削除

引数    FILE.l      ディレクトリ名のポインタ

返値    d0.l    エラーコード

    　FILE で指定したサブディレクトリを削除する。指定するディレクトリは空でな
    くてはならず、またカレントディレクトリ・ルートディレクトリやシステム属性・
    読み込み専用属性のディレクトリは削除できない。

    　成功した際の返値は通常 d0.l = 0 だが、特殊デバイスドライバが対象の場合は
    正の整数が返ることがある。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

コード例
    pea (FILE)
    DOS _RMDIR
    addq.l #4,sp

==============================================================================

$ff3b   _CHDIR          カレントディレクトリの変更

引数    FILE.l      ディレクトリ名のポインタ

返値    d0.l    エラーコード

    　カレントディレクトリを FILE で指定したディレクトリに変更する。

    　成功した際の返値は通常 d0.l = 0 だが、特殊デバイスドライバが対象の場合は
    正の整数が返ることがある。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    　長さが22文字のサブディレクトリへの変更が失敗する。

    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

コード例
    pea (FILE)
    DOS _CHDIR
    addq.l #4,sp

==============================================================================

$ff3c   _CREATE         ファイルの作成

引数    FILE.l      ファイル名のポインタ
        ATR.w       ファイル属性(%XLAD_VSHR)

返値    d0.l    作成したファイルのファイルハンドル(負数ならエラーコード)

    　FILE で指定したファイルを ATR で指定した属性で作成し、オープンする。シェ
    アリングモードは互換モードとして扱われる。同名ファイルが既に存在していた場
    合はそのファイルの内容は失われるが、それがディレクトリかボリュームラベル、
    またはシステム属性・読み込み専用属性のファイルであった場合には削除されずエ
    ラーになる。

    　ATR が0の場合はアーカイブ属性(%0010_0000)と見なされる。また、Human68k
    version 3.00 以降で ATR の最上位ビットを立てると、同名ファイルが存在するか
    どうかの検索を行わず、常に新しいファイルを作成する。これは dirsch=on の設
    定をより高速化する為の機能であるが、既に存在するファイル名を指定した場合は
    同名のファイルが複数存在することになってしまうので注意すること。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

コード例
    move ATR,-(sp)
    pea (FILE)
    DOS _CREATE
    addq.l #6,sp

==============================================================================

$ff3d   _OPEN           ファイルのオープン

引数    FILE.l      ファイル名のポインタ
        MODE.w      アクセスモード

返値    d0.l    オープンしたファイルのファイルハンドル(負数ならエラーコード)

    　FILE で指定したファイルを MODE で指定したアクセスモードでオープンする。
    システム属性・読み込み専用属性のファイルを書き込み・読み書きモードでオープ
    ンすることはできない。

    　MODE の内容は以下の通り。
        bit    8    辞書アクセスモード
                    %1      辞書用の特殊なファイルハンドルを使用する
                            (ユーザーは使用禁止)。
                    %0      通常
        bit 6～4    シェアリングモード
                    %100    常に許可
                    %011    書き込みのみ許可
                    %010    読み込みのみ許可
                    %001    常に禁止
                    %000    互換モード
        bit 1～0    リード/ライトモード
                    %10     読み込み/書き込みモード
                    %01     書き込みモード
                    %00     読み込みモード

    　ビット6～4で指定するシェアリングモードとは、複数のプロセスによるファイル
    の共有を規制するもので、複数のプロセスが並列に実行されている場合、同一ファ
    イルに対して複数のプロセスが同時に読み書きを行う恐れがあるので、適切なシェ
    アリングモードを指定して、ファイルアクセスの排他制御を行う必要がある。

    　ビット8で指定する辞書アクセスモードでは同時に2個のファイルまでオープンで
    きる。ASK68K ver.3.0 では ASK68K 本体で1個使用するので、もう1個をアクセサ
    リで使用できる。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

コード例
    move MODE,-(sp)
    pea (FILE)
    DOS _OPEN
    addq.l #6,sp

==============================================================================

$ff3e   _CLOSE          ファイルのクローズ

引数    FILENO.w        ファイルハンドル

返値    d0.l    エラーコード

    　FILENO で指定したファイルハンドルをクローズする。

    　ファイルを更新後にクローズすると、ファイル変更日時がクローズ時の日時に設
    定される。またファイル属性がオープン時の値に戻される。

    　Human68k version 3.00 以降では、_DUP で複写したハンドルをクローズした場
    合にも標準ブロックデバイスに対してはファイル名や変更日時の書き込みを行う。

コード例
    move FILENO,-(sp)
    DOS _CLOSE
    addq.l #2,sp

==============================================================================

$ff3f   _READ           ファイルから読み込む

引数    FILENO.w        ファイルハンドル
        BUFFER.l        読み込みバッファのポインタ
        LEN.l           読み込むバイト数

返値    実際に読み込んだバイト数(負数ならエラーコード)

        FILENO で指定したファイルハンドルから、LEN で指定するバイト数を BUFFER
        で指定するバッファに読み込む。実行後、ファイルポインタは読み込んだバイ
        ト数だけ後方に移動する。
        返値が指定したバイト数より小さければ、ファイルを終わりまで読み込んだこ
        とを意味する。

        move.l  LEN,-(sp)
        pea     (BUFFER)
        move    FILENO,-(sp)
        DOS     _READ
        lea     (10,sp),sp

==============================================================================

$ff40   _WRITE          ファイルへ書き込む

引数    FILENO.w        ファイルハンドル
        BUFFER.l        書き込みバッファのポインタ
        LEN.l           書き込むバイト数

返値    実際に書き込んだバイト数(負数ならエラーコード)

        FILENO で指定したファイルハンドルに、LEN で指定するバイト数を BUFFER
        で指定するバッファから書き込む。実行後、ファイルポインタは書き込んだバ
        イト数だけ後方に移動する。LEN = 0 の場合は現在のファイルポインタ位置以
        降を切り捨て、ファイルサイズを縮小する。
        返値が指定したバイト数より小さい時は、ディスクの空き容量が足りなくなっ
        たことを意味する。

        move.l  LEN,-(sp)
        pea     (BUFFER)
        move    FILENO,-(sp)
        DOS     _WRITE
        lea     (10,sp),sp

==============================================================================

$ff41   _DELETE         ファイルの削除

引数    FILE.l      ファイル名のポインタ

返値    d0.l    エラーコード

    　FILE で指定したファイルを削除する。ワイルドカードの指定や、ディレクトリ
    かボリュームラベル、またはシステム属性・読み込み専用属性のファイルの削除は
    できない。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

コード例
    pea (FILE)
    DOS _DELETE
    addq.l #4,sp

==============================================================================

$ff42   _SEEK           ファイルポインタの移動

引数    FILENO.w    ファイルハンドル
        OFFSET.l    オフセット
        MODE.w      移動モード

返値    d0.l    先頭からのオフセット(負数ならエラーコード)

    　FILENO で指定したファイルのポインタを、MODE で指定した位置から OFFSET で
    指定したバイト数だけ移動する。ポインタをファイル終端以降もしくは先頭より前
    方に移動するとエラーになる。

    　キャラクタデバイスはシークできず、現在位置は常に d0.l = 0 が返る。

        MODE = 0    先頭
        MODE = 1    現在位置(オフセットに負数を指定することでファイル先頭方向
                    にも移動可能)
        MODE = 2    終端(オフセットは 0 もしくは負数のみ指定可能)

コード例
    move MODE,-(sp)
    move.l OFFSET,-(sp)
    move FILENO,-(sp)
    DOS _SEEK
    addq.l #8,sp

ユーザー拡張
    　XEiJ (0.24.03.08 以降)ではホストファイルシステム機能においてシーク可能範
    囲が拡張される。

==============================================================================

$ff43   _CHMOD          ファイル属性の変更

引数    FILE.l      ファイル名のポインタ
        ATR.w       ファイル属性(%XLAD_VSHR)

返値    d0.l    指定したファイルの属性(負数ならエラーコード)

    　FILE で指定したファイルを ATR で指定した属性に変更する。ATR = -1 の時は
    ファイルの属性を調べる。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

コード例
    move ATR,-(sp)
    pea (FILE)
    DOS _CHMOD
    addq.l #6,sp

==============================================================================

$ff44   _IOCTRL         デバイスドライバの ioctrl による直接入出力

　デバイスドライバに対し ioctrl による直接入出力を行う。ただし、デバイスヘッダ
の IOCTRL ビット(bit 14)が0の場合は使用できない。

　モードの引数 MD により動作モードが切り替わる。
    MD =  0 …… ファイルの装置情報を調べる (IOCTRLGT)
    MD =  1 …… ファイルに装置情報を設定する (IOCTRLST)
    MD =  2 …… ファイルからデータを読み込む (IOCTRLRH)
    MD =  3 …… ファイルにデータを書き込む (IOCTRLWH)
    MD =  4 …… ドライブからデータを読み込む (IOCTRLRD)
    MD =  5 …… ドライブにデータを書き込む (IOCTRLWD)
    MD =  6 …… ファイルの入力ステータスを調べる (IOCTRLIS)
    MD =  7 …… ファイルの出力ステータスを調べる (IOCTRLOS)
    MD =  9 …… ドライブがローカルかリモートかを調べる (IOCTRLDVGT)
    MD = 10 …… ファイルがローカルかリモートかを調べる (IOCTRLFDGT)
    MD = 11 …… リトライ数と待機時間を設定する (IOCTRLRTSET)
    MD = 12 …… ファイルの特殊コントロールを行なう (IOCTRLFDCTL)
    MD = 13 …… ドライブの特殊コントロールを行なう (IOCTRLDVCTL)

　なお、MD = 0 (IOCTRLGT)、9 (IOCTRLDVGT)、10 (IOCTRLFDGT) で得られる装置情報
について XC コンパイラのリファレンスマニュアルでは bit 13 が特殊ブロックデバイ
ス、bit 12 がリモートの情報を表すとの記述があるが、実際には bit 13 のみでリモ
ートを表す。bit 12 は Human68k からは参照されておらず、使用されていない。

MD =  0 …… ファイルの装置情報を調べる (IOCTRLGT)
    　FILENO で指定したファイルハンドルの装置情報を調べる。

    引数    MD.w        コントロールモード
            FILENO.w    ファイルハンドル

    返値    d0.l    装置情報(負数ならエラーコード)。上位バイトはデバイスヘッダ、
                    下位バイトは FCBから取得される。

                bit 15  0:ブロックデバイス       1:キャラクタデバイス
                bit 14  0:IOCTRL 不可            1:可能
                bit 13  0:ローカル               1:リモート
                bit  7  0:ブロックデバイス       1:キャラクタデバイス
                bit  6  0:特殊 IOCTRL 不可       1:可能
                bit  5  0:COOKED モード  1:RAW モード  ┐
                bit  3  1:CLOCK デバイス               │キャラクタデバイス
                bit  2  1:NUL デバイス                 │  の場合
                bit  1  1:標準出力(CON)デバイス        │
                bit  0  1:標準入力(CON)デバイス        ┘
                bit  5  0:ローカル       1:リモート    ┐ブロックデバイス
                bit 4～0 ドライブ番号                  ┘  の場合

    コード例
        move FILENO,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        addq.l #4,sp

MD =  1 …… ファイルに装置情報を設定する (IOCTRLST)
    　FILENO で指定したファイルハンドルに装置情報を設定する。変更できるのはキ
    ャラクタデバイスの COOKED/RAW モードの属性(bit 5)のみ。

    引数    MD.w        コントロールモード
            FILENO.w    ファイルハンドル
            DT.w        装置情報

    返値    d0.l    変更後の装置情報(負数ならエラーコード)。

                bit  7  0:ブロックデバイス       1:キャラクタデバイス
                bit  6  0:特殊 IOCTRL 不可       1:可能
                bit  5  0:COOKED モード  1:RAW モード  ┐
                bit  3  1:CLOCK デバイス               │キャラクタデバイス
                bit  2  1:NUL デバイス                 │  の場合
                bit  1  1:標準出力(CON)デバイス        │
                bit  0  1:標準入力(CON)デバイス        ┘
                bit  5  0:ローカル       1:リモート    ┐ブロックデバイス
                bit 4～0 ドライブ番号                  ┘  の場合

    コード例
        move DT,-(sp)
        move FILENO,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        addq.l #6,sp

MD =  2 …… ファイルからデータを読み込む (IOCTRLRH)
    　FILENO で指定したファイルハンドルから、PTR で指定したバッファに LEN で指
    定したバイト数だけ読み込む。

    引数    MD.w        コントロールモード
            FILENO.w    ファイルハンドル
            PTR.l       バッファアドレス
            LEN.l       読み込むバイト数

    返値    d0.l    実際に読み込んだバイト数(負数ならエラーコード)

    コード例
        move.l LEN,-(sp)
        pea (PTR)
        move FILENO,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        lea (12,sp),sp

MD =  3 …… ファイルにデータを書き込む (IOCTRLWH)
    　FILENO で指定したファイルハンドルに、PTR で指定したバッファから LEN で指
    定したバイト数だけ書き込む。

    引数    MD.w        コントロールモード
            FILENO.w    ファイルハンドル
            PTR.l       データアドレス
            LEN.l       書き込むバイト数

    返値    d0.l    実際に書き込んだバイト数(負数ならエラーコード)

    コード例は MD = 2 (IOCTRLRH) の項目を参照のこと。

MD =  4 …… ドライブからデータを読み込む (IOCTRLRD)
    　DRIVE で指定したドライブから、PTR で指定したバッファに LEN で指定したバ
    イト数だけ読み込む。
    　リモートドライブに対しては使用できず、エラーが返る。

    引数    MD.w        コントロールモード
            DRIVE.w     ドライブ番号(0:カレント 1:A 2:B … 26:Z)
            PTR.l       バッファアドレス
            LEN.l       読み込むバイト数

    返値    d0.l    実際に読み込んだバイト数(負数ならエラーコード)

    コード例
        move.l LEN,-(sp)
        pea (PTR)
        move DRIVE,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        lea (12,sp),sp

MD =  5 …… ドライブにデータを書き込む (IOCTRLWD)
    　DRIVE で指定したドライブに、PTR で指定したバッファから LEN で指定したバ
    イト数だけ書き込む。
    　リモートドライブに対しては使用できず、エラーが返る。

    引数    MD.w        コントロールモード
            DRIVE.w     ドライブ番号(0:カレント 1:A 2:B … 26:Z)
            PTR.l       データアドレス
            LEN.l       書き込むバイト数

    返値    d0.l    実際に書き込んだバイト数(負数ならエラーコード)

    コード例は MD = 4 (IOCTRLRD) の項目を参照のこと。

MD =  6 …… ファイルの入力ステータスを調べる (IOCTRLIS)
    　FILENO で指定したファイルハンドルの入力ステータスを調べる。

    引数    MD.w        コントロールモード
            FILENO.w    ファイルハンドル

    返値    d0.l    入力ステータス(0:不可 -1:可 それ以外の負数ならエラーコード)
                    リモートドライブの場合は常に -1 が返る。

    コード例
        move FILENO,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        addq.l #4,sp

MD =  7 …… ファイルの出力ステータスを調べる (IOCTRLOS)
    　FILENO で指定したファイルハンドルの出力ステータスを調べる。

    引数    MD.w        コントロールモード
            FILENO.w    ファイルハンドル

    返値    d0.l    出力ステータス(0:不可 -1:可 それ以外の負数ならエラーコード)
                    リモートドライブの場合は常に -1 が返る。

    コード例は MD = 6 (IOCTRLIS) の項目を参照のこと。

MD =  9 …… ドライブがローカルかリモートかを調べる (IOCTRLDVGT)
    　DRIVE で指定したドライブがローカルかリモートかを調べる。

    引数    MD.w        コントロールモード
            DRIVE.w     ドライブ番号(0:カレント 1:A 2:B … 26:Z)

    返値    d0.l    ステータス(負数ならエラーコード)。上位バイトはデバイスヘッ
                    ダから取得され、下位バイトにはドライブ番号とローカル/リモ
                    ート種別が書き込まれる。

                bit 15  0:ブロックデバイス
                bit 14  0:IOCTRL 不可    1:可能
                bit 13  0:ローカル       1:リモート
                bit  5  0:ローカル       1:リモート
                bit 4～0 ドライブ番号

    コード例
        move DRIVE,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        addq.l #4,sp

MD = 10 …… ファイルがローカルかリモートかを調べる (IOCTRLFDGT)
    　FILE で指定したドライブがローカルかリモートかを調べる。

    　実際には MD = 0 (IOCTRLGT) と同じ処理が実行されている。引数、返値、コー
    ド例はそちらを参照のこと。

MD = 11 …… リトライ数と待機時間を設定する (IOCTRLRTSET)
    　指定した COUNT 及び TIME をリトライ数、待機時間に設定する。

    引数    MD.w        コントロールモード
            COUNT.w     リトライ回数
            TIME.w      リトライ待機時間

    返値    d0.l = 0

    コード例
        move TIME,-(sp)
        move COUNT,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        addq.l #6,sp

MD = 12 …… ファイルの特殊コントロールを行なう (IOCTRLFDCTL)
    　ファイルハンドルによる特殊コントロールを行なう。

    引数    MD.w        コントロールモード
            FILENO.w    ファイルハンドル
            F_CODE.w    ファンクション番号
            PTR.l       バッファアドレス

    返値    d0.l    デバイスドライバによる(負数ならエラーコード)。
                    キャラクタデバイス、ローカルドライブでは0が返る。

    コード例
        pea (PTR)
        move F_CODE,-(sp)
        move FILENO,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        lea (10,sp),sp

    不具合
        該当環境: Human68k v3.02 (これ以外は未調査)
        　キャラクタデバイスに対して特殊 ioctrl が可能かどうかの確認をしていな
        いため、可能でないデバイスに対して実行するとエラーにせずデバイスドライ
        バを呼び出してしまう。

    不具合
        該当環境: C compilr PRO-68K (XC)
        　Human68k ではなく XC ライブラリの不具合だが、IOCTRLFDCTL() は
        MD = 13 として実装されており正しく動作しない。ver2.1 NEW KIT の拡張マ
        ニュアルでは
            int IOCTRLFDCTL(drive, f_code, buffer);
            int drive; /* ドライブ番号(0=カレント、1=A:) */
        として説明され、ドライブ番号を指定する仕様に変更された。
        参考: https://twitter.com/kamadox/status/1781955615910461638

MD = 13 …… ドライブの特殊コントロールを行なう (IOCTRLDVCTL)
    　ドライブによる特殊コントロールを行なう。

    引数    MD.w        コントロールモード
            DRIVE.w     ドライブ番号(0:カレント 1:A 2:B … 26:Z)
            F_CODE.w    ファンクション番号
            PTR.l       バッファアドレス

    返値    d0.l    デバイスドライバによる(負数ならエラーコード)。
                    ローカルドライブでは0が返る。

    　Human68k version 3.00 以降の DISK2HD デバイスでは、2HD 以外のメディアに
    対応するために以下のように拡張されている。

        F_CODE = -1 …… PTR に 'DISKdev1' の 8 バイトを返す。

        F_CODE =  0 …… PTR の先頭 1 ワードにメディアバイトを返す。

        F_CODE =  1 …… PTR には以下の情報を返す。
            offset  size
             0      1.l     trap #15 の返値(d0 の値 = エラービット)
             4      1.w     1 セクタ当りのバイト数(1024)
             6      1.b     FAT の占めるセクタ数(1)
             7      1.b     FAT 領域の個数(2)
             8      1.w     予約セクタ数(1)
            10      1.w     ルートディレクトリに入るファイルの個数(192)
            12      1.w     総セクタ数(8*77*2)
            14      1.b     メディアバイト($fe)
            15      1.b     FAT エリアセクタ数(2)
            16      1.w     ヘッダ内セクタ数(8)
            18      1.w     トラック内セクタ数(2)
            20      1.b     IOCS 制御 d1.high パラメータ($90)
            21      1.b     メディアフラグワークエリア(-1)
                            (メディアチェック用)

        F_CODE =  2 …… PTR はバッファアドレスではなく以下の値を指定する。上
                         記 PTR の最後の1バイトの値を変更する機能である。

            PTR = -1 …… 排出されたものとして BPB と DPB を再構築する。
            PTR =  0 …… IOCS _B_DRVCHK の返値に従う(通常)。
            PTR =  1 …… 排出されていないものとして、メディアチェックを1回無
                          視する。

    　なお、上記の他に特殊 ioctrl に対応しているデバイスドライバは、現在確認し
    ているものでは susie.x がある。

    コード例
        pea (PTR)
        move F_CODE,-(sp)
        move DRIVE,-(sp)
        move MD,-(sp)
        DOS _IOCTRL
        lea (10,sp),sp

    不具合
        該当環境: C compilr PRO-68K (XC)
        　Human68k ではなく XC ライブラリの不具合だが、IOCTRLDVCTL() は
        MD = 12 として実装されており正しく動作しない。ver2.1 NEW KIT の拡張マ
        ニュアルには記載がない。

==============================================================================

$ff45   _DUP            ファイルハンドルの複写

引数    FILENO.w        ファイルハンドル

返値    新しいファイルハンドル(負数ならエラーコード)

        ファイルハンドル FILENO を複写して、2 個目のファイルハンドルを作る。
        同一ファイルのファイルハンドルは、同じファイルポインタを使用するのでど
        ちらのファイルハンドルを使ってもファイルの操作が出来るようになる。

        move    FILENO,-(sp)
        DOS     _DUP
        addq.l  #2,sp

==============================================================================

$ff46   _DUP2           ファイルハンドルの強制複写

引数    FILENO.w        ファイルハンドル
        NEWNO.w         複写先のファイルハンドル

返値    エラーコード

        ファイルハンドル FILENO を 2 個目のファイルハンドル NEWNO に強制的に複
        写する。
        NEWNO で指定したファイルハンドルが既にオープンされている場合は、自動的
        にクローズしてから複写する。

        move    NEWNO,-(sp)
        move    FILENO,-(sp)
        DOS     _DUP2
        addq.l  #4,sp

==============================================================================

$ff47   _CURDIR         カレントディレクトリを得る

引数    DRIVE.w         ドライブ番号(0:カレント 1:A 2:B … 26:Z)
        BUFFER.l        バッファのポインタ

返値    エラーコード

        DRIVE で指定したドライブのカレントディレクトリを、BUFFER で指定した 65
        バイトのバッファに書き込む。ドライブ名・ルートディレクトリを表す '\'
        及び終端の '\' は付かない。

        pea     (BUFFER)
        move    DRIVE,-(sp)
        DOS     _CURDIR
        addq.l  #6,sp

==============================================================================

$ff48   _MALLOC         メモリの確保

引数    LEN.l           確保するバイト数

返値    確保したメモリブロックのポインタ(MSP＋$10)
                d0.l = $81??????        指定した量は確保不可能
                                        ($00?????? は確保可能なバイト数)
                d0.l = $8200000?        完全に確保不可能($? は不定)

        LEN で指定したバイト数のメモリを確保する。LEN が $1000000 以上の場合は
        必ずエラーになり、確保可能な最大バイト数を調べる事が出来る。

        move.l  LEN,-(sp)
        DOS     _MALLOC
        addq.l  #4,sp

==============================================================================

$ff49   _MFREE          メモリブロックの解放

引数    MEMPTR.l        メモリブロックのポインタ

返値    エラーコード

        MEMPTR で指定したメモリブロックを解放する。
        MEMPTR = 0 の時、自分が確保したメモリを全て解放する。

        pea     (MEMPTR)
        DOS     _MFREE
        addq.l  #4,sp

==============================================================================

$ff4a   _SETBLOCK       メモリブロックの変更

引数    MEMPTR.l        メモリブロックのポインタ
        LEN.l           変更するバイト数

返値    エラーコード
                d0.l = $81??????        変更不可能
                                        ($00?????? は変更可能なバイト数)
                d0.l = $8200000?        完全に変更不可能($? は不定)

        MEMPTR で指定したメモリブロックを、LEN で指定した大きさに変更する。
        LEN が $1000000 以上の場合は必ずエラーになり、変更可能な最大バイト数を
        調べる事が出来る。
        プロセス自体のメモリブロックを指定する時は LEN に PSP のサイズも含めな
        ければならない(メモリ管理ポインタのサイズは除く)。よって、DOS _KEEPPR
        で指定するサイズと同じ大きさに変更したい場合は、_KEEPPR で指定する値よ
        り 240 大きい値にする。

        move.l  LEN,-(sp)
        pea     (MEMPTR)
        DOS     _SETBLOCK
        addq.l  #8,sp

==============================================================================

$ff4b   _EXEC           プログラムのロード/実行

　指定した実行ファイルのロード、実行、またはパス検索を行う。

　モードの引数 MODE により動作モードが切り替わる。
    MODE = $00 …… ファイルをロード、実行する (LOADEXEC)
    MODE = $01 …… ファイルをロードする (LOAD)
    MODE = $02 …… パス検索を行う (PATHCHK)
    MODE = $03 …… アドレスを指定してファイルをロードする (LOADONLY)
    MODE = $04 …… ロード済みプログラムを実行する  (EXECONLY)
    MODE = $05 …… オーバーレイXファイルのモジュール番号を調べる (BINDNO)

MODE = $00 …… ファイルをロード、実行する (LOADEXEC)
    　CMDLINE でコマンドラインを、ENVPTR で環境を指定して、FILE で指定したファ
    イルをロード、実行する。

    引数    MD.w        モジュール番号及びモード(MODULE.b×256+MODE.w)
            FILE.l      ファイル名のポインタ
            CMDLINE.l   コマンドラインのポインタ
            ENVPTR.l    環境のポインタ
            TYPE.b      ファイルタイプ(FILE の上位8ビット)

    返値    d0.l    プロセス終了コード(負数ならエラーコード)
                    プロセスが終了したとき d1-d7/a1-a6 は不定。

    　ENVPTR に0を指定した場合は自分の環境を使用する。

    　MODULE でオーバーレイXファイル中の各ファイルのモジュール番号(0～255)を指
    定できる。

    　実行ファイル名の拡張子が .X .Z .R のいずれでもない場合は FILE の上位8ビ
    ットでファイルタイプ TYPE を指定し、それによってファイルの形式を指定する。
        TYPE = 1 …… .R
        TYPE = 2 …… .Z
        TYPE = 3 …… .X

    コード例
        pea (ENVPTR)
        pea (CMDLINE)
        pea (FILE)
        move.b TYPE,(sp)  ;必要な場合のみ
        move MD,-(sp)
        DOS _EXEC
        lea (14,sp),sp

MODE = $01 …… ファイルをロードする (LOAD)
    　CMDLINE でコマンドラインを、ENVPTR で環境を指定して、FILE で指定したファ
    イルをロードする。正常終了した場合は必ず MODE = 4 を実行すること。

    引数    MD.w        モジュール番号及びモード(MODULE.b×256+MODE.w)
            FILE.l      ファイル名のポインタ
            CMDLINE.l   コマンドラインのポインタ
            ENVPTR.l    環境のポインタ
            TYPE.b      ファイルタイプ(FILE の上位8ビット)

    返値    d0.l    プログラムの実行アドレス(負数ならエラーコード)
            a0.l    メモリ管理ポインタ
            a1.l    プログラムの終わり
            a2.l    コマンドライン
            a3.l    環境のポインタ
            a4.l    実行アドレス

    　ENVPTR、MODULE、TYPE については MODE = $00 (LOADEXEC) の場合と同じ。

    コード例
        MODE = $00 (LOADEXEC) と同様。

MODE = $02 …… パス検索を行う (PATHCHK)
    　ENVPTR で指定した環境から path を検索して、FILE で指定したコマンド行をフ
    ルパスのファイル名とコマンドラインに分け、FILE と CMDLINE の各ポインタに書
    き込む。

    引数    FILE.l      ファイル名のポインタ
            CMDLINE.l   コマンドラインのポインタ
            ENVPTR.l    環境のポインタ

    返値    d0.l    エラーコード

    　ファイル名バッファ FILE は90バイト以上、コマンドラインバッファ CMDLINE
    は256バイト以上必要。

    　ENVPTR については MODE = $00 (LOADEXEC) の場合と同じ。

    コード例
        pea (ENVPTR)
        pea (CMDLINE)
        pea (FILE)
        move MD,-(sp)
        DOS _EXEC
        lea (14,sp),sp

MODE = $03 …… アドレスを指定してファイルをロードする (LOADONLY)
    　LOADADR でロードアドレスを、LIMIT でリミットアドレスを指定して、FILE で
    指定したファイルをロードする。

    引数    MD.w        モジュール番号及びモード(MODULE.b×256+MODE.w)
            FILE.l      ファイル名のポインタ
            LOADADR.l   ロードアドレス
            LIMIT.l     リミットアドレス
            TYPE.b      ファイルタイプ(FILE の上位8ビット)

    返値    d0.l    プログラムの長さ(負数ならエラーコード)

    　MODULE、TYPE については MODE = $00 (LOADEXEC) の場合と同じ。

    コード例
        pea (LIMIT)
        pea (LOADADR)
        pea (FILE)
        move.b TYPE,(sp)  ;必要な場合のみ
        move MD,-(sp)
        DOS _EXEC
        lea (14,sp),sp

MODE = $04 …… ロード済みプログラムを実行する  (EXECONLY)
    　EXECADR で指定したアドレスからプログラムを実行する。MODE = $01 (LOAD) で
    ロードした後、実行する時に使用する。

    引数    EXECADR.l   実行アドレス

    返値    d0.l    プロセス終了コード(負数ならエラーコード)
                    プロセスが終了したとき d1-d7/a1-a6 は不定。

    コード例
        pea (EXECADR)
        move MD,-(sp)
        DOS _EXEC
        addq.l #6,sp

MODE = $05 …… オーバーレイXファイルのモジュール番号を調べる (BINDNO)
    　FILE で指定したオーバーレイXファイル中の、FILE2 で指定したファイルのモジ
    ュール番号を調べる。

    引数    FILE.l      ファイル名のポインタ
            FILE2.l     オーバーレイXファイル中のファイル名

    返値    d0.l    モジュール番号×256(負数ならエラーコード)

    　バインドリスト先頭からのオフセットが $fffff00 より大きいファイルは、オフ
    セット値をビット反転した数をモジュール番号として返す。ただし、このようなオ
    フセット値が負数のファイルはロード出来ない。

    不具合
        該当環境: Human68k v3.02 (これ以外は未調査)
        　FILE2 で指定したファイル名の拡張子1バイト目を 'X' に変更したファイル
        名で検索される。

    コード例
        pea (FILE2)
        pea (FILE)
        move MD,-(sp)
        DOS _EXEC
        lea (10,sp),sp

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _OPEN
    　MODE = $00、$01、$03、$05 において使用している DOS _OPEN 内でアドレスエ
    ラー等の障害が発生することがある。

==============================================================================

$ff4c   _EXIT2          終了コードを指定して終了

引数    CODE.w          終了コード

        CODE で指定した終了コードでプログラムを終了する。オープンしたファイル
        ハンドルはクローズされ、使用中のメモリブロックは全て解放される。

==============================================================================

$ff4d   _WAIT           プロセスの終了コードを得る

返値    終了コード

        実行したプロセスの終了コードを調べる。
        DOS _EXEC(MODE = 0,4) の返値と同じ。

==============================================================================

$ff4e   _FILES          ファイルを検索し、情報を得る(最初のファイル)

    　指定したファイル名とファイル属性のファイルを検索し、ファイル情報をバッフ
    ァに書き込む。ファイル名にはワイルドカード('?'、'*')が使える。

　バッファアドレスの引数 BUFFER により動作モードが切り替わる。
    BUFFER = バッファのポインタ  …………………… [1] (通常モード)
    BUFFER = バッファのポインタ + $8000_0000 …… [2] (拡張モード)

BUFFER = バッファのポインタ …… [1] (通常モード)
    　ファイル情報を53バイトのバッファに書き込む。

    引数    BUFFER.l    バッファのポインタ
            FILE.l      ファイル名のポインタ
            ATR.w       上位バイト: 補完モード($00:通常 $01:補完)
                        下位バイト: ファイル属性(%XLAD_VSHR)

    返値    d0.l    エラーコード

    　FILE で指定したファイル名にあてはまるファイルを検索する。ただし、ATR の
    下位バイトで%1を指定したビットとファイルの属性が一つでも一致したものが対象
    となる。

    　ATR の上位バイトを $01 にすると、ファイル名または拡張子がない場合にワイ
    ルドカード '*' で補完する('' の検索は '*.*'、'foo' の検索は 'foo.*' として
    扱われる)。

    offset  size
     0       1.b    ┌ 検索する属性                          ┐
     1       1.b    │ 検索するドライブ番号                  │Human68k 内部で
     2       1.l    │ 検索中のディレクトリのセクタ番号      │使用する。
     6       1.w    │ ディレクトリの残りセクタ数            │
                    │ (ルートディレクトリの場合のみ有効)    │破壊すると
     8       1.w    │ ディレクトリ上のセクタ先頭からの      │DOS _NFILES
                    │ オフセット(-1なら該当ファイルなし)    │できない。
    10       8.b    │ 検索するファイル名                    │
    18       3.b    └ 検索する拡張子                        ┘
    21       1.b    属性
    22       1.w    最終変更時刻
    24       1.w    最終変更月日
    26       1.l    ファイルサイズ
    30      23.b    ファイル名(主ファイル名＋'.'＋拡張子＋0)

    不具合
        該当環境: Human68k v3.02 (これ以外は未調査)
        参照先: DOS _NAMESTS
        　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファを
        スタック上に確保しているため、バッファ末尾を超えてデータが書き込まれる
        とシステムスタックが破壊されアドレスエラー等の障害が発生する。

    コード例
        move ATR,-(sp)
        pea (FIL)
        pea (BUFFER)
        DOS _FILES
        lea (10,sp),sp

BUFFER = バッファのポインタ + $8000_0000 …… [2] (拡張モード)
    　Human68k version 3.00 以降でのみ使える。ファイル情報を141バイトのバッフ
    ァに書き込む。ファイル名 FILE とファイル属性 ATR、返値については通常モード
    と同じ。

    　通常モードのファイル情報に加えて、検索するファイルのパス名とファイル名を
    バッファの53バイト目からの88バイトに書き込む。書き込まれる内容は、検索する
    ファイル名を DOS _NAMESTS で展開したものとほぼ同じで、先頭の2バイトが 'A:'
    形式のドライブ名となる。これらの情報は DOS _FILES を呼び出した時に一度だけ
    書き込まれる(DOS _NFILES では書き込まれない)。また、ファイル名は検索に成功
    した名称ではなく、'?' を含む検索対象のファイル名となっている。

    offset  size
     0～52  53.b    (通常モードと同じ内容)
     53      2.b    ドライブ名('A:'～'Z:')
     55     65.b    パス名('\'＋あればサブディレクトリ名＋'\')
    120      8.b    ファイル名(先頭8バイト)
    128      3.b    拡張子(3バイト)
    131     10.b    ファイル名(残りの10バイト)

    不具合
        該当環境: Human68k v3.02 (これ以外は未調査)
        　バッファの53バイト目から書き込まれるパス名が、DOS _DRVXCHG でドライ
        ブを交換している場合は絶対ドライブ名となる。

ユーザー拡張
    　TwentyOne 常駐時にはバッファに書き込まれる内部情報の一部が変更される。ま
    た TwentyOne が持つファイル名バッファ EXBUF が不足した場合はエラーコードと
    して d0.l = -8 を返す。

    offset  size
    0～9    10.b    (標準と同じ)
    10      1.l     拡張バッファのアドレス
    14      6.b     TwentyOne 拡張フラグ 'Twenty'
    20      1.b     エラーフラグ(0:OK 1:ERR)
    21      32.b    (標準と同じ)

==============================================================================

$ff4f   _NFILES         次のファイルを検索し、情報を得る

引数    BUFFER.l    バッファのポインタ

返値    d0.l    エラーコード

    　DOS _FILES で設定されたファイル情報バッファ BUFFER を使用し、次のファイ
    ルを検索してファイル情報を再度書き込む。BUFFER の内容は _FILES と同じ。

コード例
    pea (BUFFER)
    DOS _NFILES
    addq.l #4,sp

==============================================================================

$ff50   (_SETPDB)       (v2) 管理プロセス変更
$ff80   _SETPDB         管理プロセスを移す

引数    PDBADR.l        プロセス管理ポインタ

返値    以前のプロセス管理ポインタ

        PDBADR で指定したプロセスに管理を移す。
        PDBADR は _GETPDB で得られたアドレスでなければならない。

        pea     (PDBADR)
        DOS     _SETPDB)
        addq.l  #4,sp

==============================================================================

$ff51   (_GETPDB)       (v2) プロセス情報収得
$ff81   _GETPDB         現在のプロセス情報を得る

返値    現在のプロセス管理ポインタ

        現在のプロセスを表すプロセス管理ポインタを収得する。

==============================================================================

$ff52   (_SETENV)       (v2) 環境変数設定
$ff82   _SETENV         環境変数の設定

引数    ENVNAME.l       環境変数名のポインタ
        ENVPTR.l        環境のポインタ
        ENVVAL.l        変数の値のポインタ

返値    エラーコード

        ENVPTR で指定した環境の ENVNAME で指定した変数に、ENVVAL で指定した最
        大 255 バイトの環境変数を設定する。ただし、ENVVAL = 0 の時や ENVVAL に
        空文字列を指定した場合は、ENVNAME で指定した変数を消去する。
        ENVPTR に 0 を指定すると自分の環境を使用する。
        Human68k version 3.02 では正常に動作しない(環境変数の値が 255 バイトを
        超えている時に暴走する)。

        pea     (ENVVAL)
        pea     (ENVPTR)
        pea     (ENVNAME)
        DOS     _SETENV
        lea     (12,sp),sp

==============================================================================

$ff53   (_GETENV)       (v2) 環境変数収得
$ff83   _GETENV         環境変数の内容を得る

引数    ENVNAME.l       環境変数名のポインタ
        ENVPTR.l        環境のポインタ
        BUFFER.l        バッファのポインタ

返値    エラーコード

        ENVPTR で指定した環境の、ENVNAME で指定した環境変数の内容を BUFFER で
        指定した 256 バイトのバッファに書き込む。
        ENVPTR に 0 を指定すると自分の環境を使用する。

        pea     (BUFFER)
        pea     (ENVPTR)
        pea     (ENVNAME)
        DOS     _GETENV
        lea     (12,sp),sp

==============================================================================

$ff54   (_VERIFYG)      (v2) ベリファイフラグ収得
$ff84   _VERIFYG        ベリファイフラグを得る

返値    設定状況(0:ベリファイしない 1:ベリファイする)

        ベリファイフラグを調べる。

==============================================================================

$ff55   (_COMMON)       (v2) common 領域制御
$ff85   _COMMON         common 領域の制御

引数    MD.w            コントロールモード
        NAME.l          common 領域名のポインタ
        POS.l           ポジション(common 領域の先頭からのバイト数)
        BUFFER.l        バッファのポインタ
        ID_PSP.l        プロセス ID
        LEN.l           バイト長

返値    MD = 0
                common 領域のバイト数(負数ならエラーコード)
        MD = 1,2
                実際に読み書きしたバイト数(負数ならエラーコード)
        MD = 3～5
                エラーコード

        モード MD の値に従って common 領域を制御する。
        この DOS コールによりプロセス間通信が簡単に実現出来る。

        MD = 0
                NAME で指定した common 領域が存在するか調べ、存在した場合は領
                域の大きさを返す。
        MD = 1
                NAME で指定した common 領域の、POS で指定した位置から LEN で指
                定したバイト数を、BUFFER で指定したバッファに読み込む。
        MD = 2
                NAME で指定した common 領域に、POS で指定した位置から LEN で指
                定したバイト数だけ、BUFFER で指定したバッファから書き込む。
                NAME で指定した common 領域が存在しない場合は作成する。
                LEN に 0 を指定すると切り詰める。
        MD = 3
                NAME で指定した common 領域の、POS で指定した位置から LEN で指
                定したバイト数を、ID_PSP でプロセスを指定してロックする。
                ID_PSP で指定されたプロセス以外のアクセスが禁止される。
        MD = 4
                NAME で指定した common 領域の、POS で指定した位置から LEN で指
                定したバイト数を、ID_PSP でプロセスを指定してロックを解除する。
                ID_PSP で指定されたプロセス以外のアクセスが許可される。
        MD = 5
                NAME で指定した common 領域を削除する。

MD = 0,5
        pea     (NAME)
        move    MD,-(sp)
        DOS     _COMMON
        addq.l  #6,sp

MD = 1,2
        move.l  LEN,-(sp)
        pea     (BUFFER)
        move.l  POS,-(sp)
        pea     (NAME)
        move    MD,-(sp)
        DOS     _COMMON
        lea     (18,sp),sp

MD = 3,4
        move.l  LEN,-(sp)
        move.l  ID_PSP,-(sp)
        move.l  POS,-(sp)
        pea     (NAME)
        move    MD,-(sp)
        DOS     _COMMON
        lea     (18,sp),sp

==============================================================================

$ff56   (_RENAME)       (v2) ファイル名変更/移動
$ff86   _RENAME         ファイル名の変更/移動

引数    OLD.l   ファイル名のポインタ
        NEW.l   新ファイル名のポインタ

返値    d0.l    エラーコード

    　OLD で指定したファイルを、NEW で指定したファイル名に変更する。システム属
    性・読み込み専用属性のファイルはリネームできない。

    　OLD と NEW のパスが異なる場合はファイルを移動するが、異なるドライブ間の
    移動や、ディレクトリやボリュームラベル、隠し属性・読み込み専用属性のファイ
    ルの移動はできない。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    　新旧両方のファイルが存在し、かつ双方の先頭 FAT 番号及びファイルサイズの
    上位ワードが等しい場合に、新ファイル名にリネームされる。これは双方がボリュ
    ームラベルの場合に該当する。
    　移動先のディレクトリに空きがない場合にファイルが消滅する。
    　リネームが移動と見なされることがある。

    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。
    　NEW で指定された新ファイル名の処理が該当し、OLD の処理では発生しない。

コード例
    pea (NEW)
    pea (OLD)
    DOS _RENAME
    addq.l #8,sp

==============================================================================

$ff57   (_FILEDATE)     (v2) ファイル変更日時収得/設定
$ff87   _FILEDATE       ファイルの日付/時間の読み出し/設定

引数    FILENO.w        ファイルハンドル
        DATETIME.l      日付及び時間

返値    DATETIME = 0
                ファイルの日時
        DATETIME = その他
                上位ワードが $ffff の時のみエラーコード
                このコールでは負数でもエラーコードではない場合がある。

        FILENO で指定したファイルハンドルの日付と時間の収得/設定をする。
        DATETIME = 0 の場合は収得、それ以外の場合は設定を行う。

        %yyyy_yyym_mmmd_dddd_tttt_tfff_fffs_ssss
        bit 31～25      年-1980(0～127)
        bit 24～21      月  (1～12 月)
        bit 20～16      日  (1～31 日)
        bit 15～11      時  (0～23 時)
        bit 10～ 5      分  (0～59 分)
        bit  4～ 0      秒/2(0～29 秒)

        秒は 2 秒単位で表し、実際の秒を 2 で割った値を設定する。

        move.l  DATETIME,-(sp)
        move    FILENO,-(sp)
        DOS     _FILEDATE
        addq.l  #6,sp

==============================================================================

$ff58   (_MALLOC2)      (v2) メモリ確保
$ff88   _MALLOC2        指定の方法によるメモリの確保

引数    MD.w            コントロールモード
        LEN.l           確保するバイト数
        PTR.l           管理するプロセスのプロセス管理ポインタ

返値    確保したメモリブロックのポインタ
                d0.l = $81??????        指定された量は確保不可能
                                        ($00?????? は確保可能なバイト数)
                d0.l = $8200000?        完全に確保不可能($? は不定)

        LEN で指定したバイト数のメモリを確保する。LEN が $01000000(16M)以上の
        場合は必ずエラーになり、確保可能な最大バイト数を調べる事が出来る。MD
        にはメモリを確保する方法を指定する。

        MD = 0  下位から検索
        MD = 1  必要最小ブロックから検索
        MD = 2  上位から検索

        Human68k version 3.00 以降では、MD の値が以下の値の時、親のプロセス管
        理ポインタの先頭アドレスを PTR で指定することで、常駐プログラムやデバ
        イスドライバからのメモリ確保が可能である。

        MD = $8000      下位から検索
        MD = $8001      必要最小ブロックから検索
        MD = $8002      上位から検索

[MD = 0,1,2]
        move.l  LEN,-(sp)
        move    MD,-(sp)
        DOS     _MALLOC2
        addq.l  #6,sp

[MD = $8000,$8001,$8002]
        pea     (PTR)
        move.l  LEN,-(sp)
        move    MD,-(sp)
        DOS     _MALLOC2
        lea     (10,sp),sp

==============================================================================

$ff5a   (_MAKETMP)      (v2) テンポラリファイル作成
$ff8a   _MAKETMP        テンポラリファイルの作成

引数    FILE.l      ファイル名のポインタ
        ATR.w       ファイル属性(%XLAD_VSHR)

返値    d0.l    作成したファイルのファイルハンドル(負数ならエラーコード)

    　FILE で指定したテンポラリファイルを ATR で指定した属性で作成する。ATR が
    0 の場合はアーカイブ属性(%0010_0000)と見なされる。

    　ファイル名には '?' を含めることができ、作成時に数字に置き換えられて存在
    しないファイル名になるまで加算して検索される。数字を指定した場合はその数字
    から検索される。

    　ファイル名の置き換えは、Human68k version 3.02 では以下のような手順で行わ
    れる。

    　まず、ファイル名として指定した文字列のうち、ファイル名部分(最後の ':'、
    '\'、'/' 以降)に含まれるすべての '?' を '0' に置き換え、同名のファイルが存
    在しなければファイルを作成してファイルハンドルを返す。

    　ファイルが存在した場合はファイル名部分の最後の数字に1を加算する('?' から
    置き換えた '0' だけでなく元から含まれる数字も対象となる)。ただし数字が '9'
    であった場合は '0' に戻し、繰り上がりとして上位桁も置き換える。再びファイ
    ル作成を試み、成功するまで繰り返す。

    　全ての数字が '9' からの繰り上がりで '0' に戻った場合はエラーを返す。

注意
    　FILE で指定したファイル名はこの DOS コールにより書き換えられるので、書き
    換え可能なメモリを指定すること。

    　作成したファイルはクローズしても削除されずに残る。不要な場合は各自で削除
    する必要がある。

    　Human68k の標準仕様ではファイル名の主ファイル名部分は8バイトまでしか判別
    されず、それ以降に '?' や数字が含まれていても同名ファイルの有無の判定には
    寄与しない。そのようなファイル名では、加算処理が繰り返されることにより終了
    するまでに時間がかかることがあるので注意すること。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    　ファイル名部分の抽出の際に文字コードの1バイト目が $f0 以上の文字が1バイ
    ト文字として扱われる。このため2バイト目がパス区切り(':'、'\'、'/')と同じ数
    値の文字(例: $f05c)はパス区切りとみなされてしまう。

    参照先: DOS _OPEN
    　使用している DOS _NEWFILE 内でアドレスエラー等の障害が発生することがある。

コード例
    move ATR,-(sp)
    pea (FILE)
    DOS _MAKETMP
    addq.l #6,sp

==============================================================================

$ff5b   (_NEWFILE)      (v2) ファイル作成
$ff8b   _NEWFILE        ファイルの作成

引数    FILE.l      ファイル名のポインタ
        ATR.w       ファイル属性(%XLAD_VSHR)

返値    d0.l    作成したファイルのファイルハンドル(負数ならエラーコード)
                d0.l = -80 …… 指定したファイルは既に存在している

    　FILE で指定したファイルを ATR で指定した属性で作成する。ATR が0の場合は
    アーカイブ属性(%0010_0000)と見なされる。

    　指定したファイルが既に存在している場合はエラーになる(d0.l = -80)。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    参照先: DOS _NAMESTS
    　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファをスタ
    ック上に確保しているため、バッファ末尾を超えてデータが書き込まれるとシステ
    ムスタックが破壊されアドレスエラー等の障害が発生する。

コード例
    move ATR,-(sp)
    pea (FILE)
    DOS _NEWFILE
    addq.l #6,sp

==============================================================================

$ff5c   (_LOCK)         (v2) ファイルロック
$ff8c   _LOCK           ファイルのロック

引数    MD.w            コントロールモード
        FILENO.w        ファイルハンドル
        OFFSET.l        ファイル先頭からのオフセット
        LEN.l           ロック/ロック解除するバイト数

返値    エラーコード

        モード MD の値に従って、FILENO で指定したファイルのに対するアクセスの
        ロック/ロック解除を行なう。
        ファイルのロックとは、ファイルアクセスの排他制御で、他のプロセスからの
        ファイルアクセスを禁止することである。

        MD = 0
                OFFSET で指定した位置から LEN で指定したバイト数だけロックする。
        MD = 1
                OFFSET で指定した位置から LEN で指定したバイト数だけロックを解
                除する。

        move.l  LEN,-(sp)
        move.l  OFFSET,-(sp)
        move    FILENO,-(sp)
        move    MD,-(sp)
        DOS     _LOCK
        lea     (12,sp),sp

==============================================================================

$ff5f   (_ASSIGN)       (v2) 仮想ドライブ/ディレクトリ割り当て収得/設定/解除
$ff8f   _ASSIGN         仮想ドライブ/ディレクトリの割り当ての収得/設定/解除

　仮想ドライブ・仮想ディレクトリの割り当ての収得、設定、解除を行なう。

　コントロールモードの引数 MD により動作モードが切り替わる。
    MD = 0 …… 割り当てを収得する (GETASSIGN)
    MD = 1 …… 割り当てを設定する (MAKEASSIGN)
    MD = 4 …… 割り当てを解除する (RASSIGN)

MD = 0 …… 割り当てを収得する (GETASSIGN)
    　BUFFER1 で指定したドライブの割り当てを収得し、BUFFER2 に書き込む。

    引数    BUFFER1.l   仮想ドライブ・仮想ディレクトリのポインタ
            BUFFER2.l   実ドライブ・実ディレクトリのポインタ

    返値    d0.l    割り当てモード(負数ならエラーコード)
                        d0.l = $00 …… ドライブが存在しない
                        d0.l = $40 …… 割り当てが存在しない(実ドライブ)
                        d0.l = $50 …… 仮想ドライブの割り当て
                        d0.l = $60 …… 仮想ディレクトリの割り当て

    コード例
        pea (BUFFER2)
        pea (BUFFER1)
        move MD,-(sp)
        DOS _ASSIGN
        lea (10,sp),sp

MD = 1 …… 割り当てを設定する (MAKEASSIGN)
    　割り当てモード MODE で指定した値に従って、BUFFER1 で指定したドライブに
    BUFFER2で指定したディレクトリを割り当てる。

    引数    BUFFER1.l   仮想ドライブ・仮想ディレクトリのポインタ
            BUFFER2.l   実ドライブ・実ディレクトリのポインタ
            MODE.w      割り当てモード
                MODE = $50(仮想ドライブ)
                    BUFFER1 のドライブに BUFFER2 のディレクトリを割り当てる。
                MODE = $60(仮想ディレクトリ)
                    BUFFER2 のディレクトリに BUFFER1 のドライブを割り当てる。

    返値    d0.l    エラーコード

    不具合
        該当環境: Human68k v3.02 (これ以外は未調査)
        　補完モードで DOS _FILES しているため、違うディレクトリ名へ割り当てて
        しまう。
        　'..' 及び '.' エントリのないサブディレクトリには割り当てられない。

    不具合
        該当環境: Human68k v3.02 (これ以外は未調査)
        参照先: DOS _NAMESTS
        　DOS _NAMESTS の内部ルーチンを呼び出しているが、そのためのバッファを
        スタック上に確保しているため、バッファ末尾を超えてデータが書き込まれる
        とシステムスタックが破壊されアドレスエラー等の障害が発生する。

    コード例
        move MODE,-(sp)
        pea (BUFFER2)
        pea (BUFFER1)
        move MD,-(sp)
        DOS _ASSIGN
        lea (12,sp),sp

MD = 4 …… 割り当てを解除する (RASSIGN)
    　BUFFER1 で指定したドライブの割り当てを解除する。

    引数    BUFFER1.l   仮想ドライブ・仮想ディレクトリのポインタ

    返値    d0.l    エラーコード

    コード例
        pea (BUFFER1)
        move MD,-(sp)
        DOS _ASSIGN
        addq.l #6,sp

==============================================================================

$ff60   (_MALLOC3)      (v2) 060turbo メモリ確保
$ff90   _MALLOC3        060turbo メモリ確保

        060turbo 用ドライバ 060turbo.sys を組み込むことで追加されるファンクシ
        ョンコール。DOS _MALLOC のハイメモリ対応版。

==============================================================================

$ff61   (_SETBLOCK2)    (v2) 060turbo メモリブロック変更
$ff91   _SETBLOCK2      060turbo メモリブロック変更

        060turbo 用ドライバ 060turbo.sys を組み込むことで追加されるファンクシ
        ョンコール。DOS _SETBLOCK のハイメモリ対応版。

==============================================================================

$ff62   (_MALLOC4)      (v2) 060turbo メモリ確保
$ff92   _MALLOC4        060turbo メモリ確保

        060turbo 用ドライバ 060turbo.sys を組み込むことで追加されるファンクシ
        ョンコール。DOS _MALLOC2 のハイメモリ対応版。

==============================================================================

$ff63   (_S_MALLOC2)    (v2) 060turbo メインメモリ管理下メモリブロック確保
$ff93   _S_MALLOC2      060turbo メインメモリ管理下メモリブロック確保

        060turbo 用ドライバ 060turbo.sys を組み込むことで追加されるファンクシ
        ョンコール。DOS _S_MALLOC のハイメモリ対応版。

==============================================================================

$ff7a   (_FFLUSH_SET)   (v2) FFLUSH モードの設定
$ffaa   _FFLUSH_SET     FFLUSH モードの設定

引数    MODE.w          モード
                MODE =  0       _FFLUSH を無効にする
                        1       _FFLUSH を有効にする
                        -1      現在のモードを収得する

返値    変更前のモード

        DOS _FFLUSH の有効、無効を制御する。プログラム内で _FFLUSH を使用して
        頻繁にバッファをフラッシュしている時、FASTIO.X、FASTOPEN.X、FASTSEEK.X
        などの外部コマンドを常駐していても、高速化があまり有効にならない場合が
        ある。このような場合は、このコールで _FFLUSH を無効にしておくことによ
        り、高速化を有効にすることが出来る。ただし、バッファのフラッシュを実行
        しない事は危険なので、通常の使用では有効にしておくこと。

        このコールは Human68k version 3.00 以降で使用可能。

        move    #MODE,-(sp)
        DOS     _FFLUSH_SET
        addq.l  #2,sp

==============================================================================

$ff7b   (_OS_PATCH)     (v2) OS 内部処理切り換え(システム専用コール)
$ffab   _OS_PATCH       OS 内部処理切り換え(システム専用コール)

引数    PATCH_NO.w      モード及び機能番号(MD.b×256＋ID.b)
        PATCH_ADR.l     アドレス

返値    MD = 0
                変更前の分岐命令表のアドレス
        MD = その他、または PATCH_ADR = 0
                エラーコード

        Human68k の内部処理を切り換える。パッチする機能番号を ID で、分岐命令
        表を PATCH_ADR で指定することにより、任意の処理に変更できる。ID の内容
        は以下の通り。

        ID = 1  FASTIO.X
        ID = 2  FASTSEEK.X
        ID = 3  FASTOPEN.X
        ID = 4  TwentyOne.x

        PATCH_ADR を 0 にするか、MD に 0 以外を指定すると、パッチ処理は行わず
        に最初のエントリ(常駐解除)を呼び出す。その際 MD.b を d1.w の上位 8 バ
        イトに、PATCH_ADR を d2.l に代入して呼び出すので、常駐解除以外の常駐部
        とのインターフェイスとして使用することも出来る。

        また、PATCH_ADR に -1 を指定すると、パッチは行なわずに 2 番目のエント
        リ(クローズ)及び 3 番目(初期化)を呼び出すので、常駐しているプログラム
        の初期化を行うことが出来る。

        分岐命令表は、各機能の処理アドレスに分岐する jmp (abs).l 命令を 18 個
        (ID = 3 の時)、または 20 個(ID = 1、2、4 の時)並べたもの。

        このコールは Human68k version 3.00 以降で使用可能だが、システム内部の
        詳細な知識が必要な為、システム専用とする。

        pea     (PATCH_ADR)
        move    #PATCH_NO,-(sp)
        DOS     _OS_PATCH
        addq.l  #6,sp

==============================================================================

$ff7c   (_GET_FCB_ADR)  (v2) FCB ポインタ収得
$ffac   _GET_FCB_ADR    FCB ポインタ収得

引数    FILENO.w        ファイルハンドル

返値    d0.l    FCB のポインタ(負数ならエラーコード)

    　FILENO で指定したファイルの FCB のポインタを返す。OS 内部の FCB をそのま
    ま返すので、不用意に書き換えたりしないこと。また、このアドレスはスーパバイ
    ザ領域であるのでユーザモードではアクセスできない。

    　当初は非公開ファンクションコールだったため非公式に _GETFCB と呼ばれるこ
    ともあるが、XC ver2.1 NEW KIT で _GET_FCB_ADR として公開された。

    　FCB の大きさは 96 バイトで、内容は以下の通り。

offset  size
$00      1.b    この FCB に対応しているファイルハンドルの数
$01      1.b    デバイス情報(bit 7=0 の時は bit 4～0 でドライブ名を保持する)
                        bit 7   0:ブロックデバイス 1:キャラクタデバイス
                        bit 6   更新フラグ
                        bit 5   0:Local 1:Remote  ブロックデバイスの場合
                        bit 5   0:COOKED 1:RAW   ┐
                        bit 3   CLOCK   デバイス │
                        bit 2   NUL     デバイス │キャラクタデバイスの場合
                        bit 1   標準出力デバイス │
                        bit 0   標準入力デバイス ┘
$02      1.l    ブロックデバイス   : DPB のアドレス
                キャラクタデバイス : デバイスドライバへのポインタ
$06      1.l    ファイルポインタ
$0a      1.l    排他制御情報へのポインタ
$0e      1.b    アクセスモード
$0f      1.b    ディレクトリ上の位置(セクタ先頭からの個数:0～31)
                (キャラクタデバイスでは未使用)
$10      1.b    アクセス中のクラスタ中のセクタ
$11      1.b    (未使用)
$12      1.w    アクセス中のクラスタ番号
$14      1.l    アクセス中のセクタ番号
$18      1.l    I/O バッファ先頭
$1c      1.l    対応するディレクトリエントリのセクタ番号
                (キャラクタデバイスでは未使用)
$20      1.l    最終アクセスポインタ(_SEEK しなければファイルポインタと同じ値)
$24      8.b    ファイル名1(先頭8バイト、余白は $20)
$2c      3.b    拡張子(余白は $20、ただしキャラクタデバイスは $00)
$2f      1.b    ファイル属性
$30     10.b    ファイル名2(残りの10バイト、余白は $00)
$3a      1.w    最終更新時刻
$3c      1.w    最終更新年月日
$3e      1.w    先頭の FAT 番号
$40      1.l    ファイルサイズ
$44      7.l    FAT キャッシュ
                (上位ワード:先頭からのクラスタ数 下位ワード:FAT 番号)

コード例
    move FILENO,-(sp)
    DOS _GET_FCB_ADR
    addq.l #2,sp

==============================================================================

$ff7d   (_S_MALLOC)     (v2) メインメモリ管理下メモリブロック確保
$ffad   _S_MALLOC       メインのメモリ管理下からのメモリブロックの確保する

引数    MD.w            コントロールモード
        LEN.l           確保するバイト数
        PTR.l           管理するプロセスのプロセス管理ポインタ

返値    確保したメモリブロックのポインタ
                d0.l = $81??????        指定された量は確保不可能
                                        ($00?????? は確保可能なバイト数)
                d0.l = $8200000?        完全に確保不可能($? は不定)

        メインのメモリ管理下から LEN で指定したバイト数のメモリを確保する。LEN
        が $01000000(16M)以上の場合は必ずエラーになり、確保可能な最大バイト数
        を調べる事が出来る。MD にはメモリを確保する方法を指定する。

        MD = 0  下位から検索
        MD = 1  必要最小ブロックから検索
        MD = 2  上位から検索

        Human68k version 3.00 以降では、MD の値が以下の値の時、親のプロセス管
        理ポインタの先頭アドレスを PTR で指定することで、常駐プログラムやデバ
        イスドライバからのメモリ確保が可能である。

        この DOS コールは、通常のアプリケーションプログラムで使用してはいけな
        い。常駐するプログラムのみ使用出来る。

[MD = 0,1,2]
        move.l  LEN,-(sp)
        move    MD,-(sp)
        DOS     _S_MALLOC
        addq.l  #6,sp

[MD = $8000,$8001,$8002]
        pea     (PTR)
        move.l  LEN,-(sp)
        move    MD,-(sp)
        DOS     _S_MALLOC
        lea     (10,sp),sp

==============================================================================

$ff7e   (_S_MFREE)      (v2) メインメモリ管理下メモリブロック解放
$ffae   _S_MFREE        メインのメモリ管理下のメモリブロックの解放

引数    MEMPTR.l        メモリ管理ポインタ

返値    エラーコード

        MEMPTR で指定した、メインのメモリ管理下のメモリブロックを解放する。
        MEMPTR が S_PROCESS で指定したサブのメモリ管理ポインタで、かつそのスレ
        ッド ID がカレント ID なら、KILL_PR でプロセスを削除する。その場合サブ
        のメモリ管理下で常駐終了しているプロセスは、メインのメモリ管理下に入る。
        MEMPTR に 0 を指定した場合、自分が確保したメモリを全て解放する。
        Human68k version 3.02 では正常に動作しない(常駐終了していたプロセスの
        メモリブロックが破壊される)。

        pea     (MEMPTR)
        DOS     _S_MFREE
        addq.l  #4,sp

==============================================================================

$ff7f   (_S_PROCESS)    (v2) サブメモリ管理設定
$ffaf   _S_PROCESS      サブのメモリ管理の設定

引数    ID.w            スレッド ID
        START.l         サブのメモリ管理ポインタ
        LENGTH.l        メモリブロック全体のバイト数
        I_LEN.l         先頭ブロックのバイト数

返値    先頭のメモリブロック(サイズはI_LEN)のポインタ
                d0.l = $ffff00??        ID エラー($?? は ID の最大値)
                d0.l = -14              LENGTH が I_LEN＋16 より小さい

        START で指定した先頭アドレスと LENGTH で指定したバイト数で、サブのメモ
        リ管理を設定する。サブのメモリ管理を新しく設定する際には、必ず先頭から
        1 ブロックだけ自動的に確保されるので、そのバイト数 I_LEN を指定する。
        以後指定した ID を持つスレッドからのメモリ確保要求は、このサブのメモリ
        管理下に限定される。

        move.l  I_LEN,-(sp)
        move.l  LENGTH,-(sp)
        pea     (START)
        move    ID,-(sp)
        DOS     _S_PROCESS
        lea     (14,sp),sp

==============================================================================

$fff0   _EXITVC         (プログラム終了時の実行アドレス)

        これは DOS コールではなく、INTVCS でこのベクタに処理アドレスを設定して
        おくことにより、プログラム終了時にそのアドレスを呼び出すことが出来る。

        通常は親プロセスが子プロセスを起動する為に実行した DOS _EXEC の直後の
        アドレスが設定され、子プロセスが DOS _EXIT 等で終了した時に DOS コール
        から戻るアドレスとして参照される。呼び出されるのは DOS コールの処理が
        全て終わった後であるから、DOS _EXIT 等を実行したプロセスは既に削除され、
        元の親プロセスに制御が移っている状態である。

        このベクタはプロセスの起動ごとに書き換えられ、PSP に複写される。実際に
        参照されるのは PSP 内の値であるので、直接 DOS コールのベクタテーブルを
        書き換えても反映されない。

==============================================================================

$fff1   _CTRLVC         (CTRL+C によるアボート時の実行アドレス)

        これは DOS コールではなく、INTVCS でこのベクタに処理アドレスを設定して
        おくことにより、ブレークでアボートした時にそのアドレスを呼び出すことが
        出来る。

        初期状態では単に DOS _EXIT を実行するだけのルーチンが設定されている。
        CTRL+C によるアボートは DOS コール実行中にのみ発生するが、設定したアド
        レスは DOS コールを強制終了してから呼び出される(呼び出された時は既に
        DOS コール実行中ではなく、ネストしていてもその時点で完全に終了する)。

        このベクタは自動的には変更されず、変更した場合は子プロセス全てがその値
        を継承する。

==============================================================================

$fff2   _ERRJVC         (エラーによるアボート時の実行アドレス)

        これは DOS コールではなく、INTVCS でこのベクタに処理アドレスを設定して
        おくことにより、エラーでアボートした時にそのアドレスを呼び出すことが出
        来る。

        初期状態では単に DOS _EXIT を実行するだけのルーチンが設定されている。

        このベクタは自動的には変更されず、変更した場合は子プロセス全てがその値
        を継承する。

==============================================================================

$fff3   _DISKRED        ブロックデバイスから直接読み込む

引数    BUFFER.l        読み込むバッファのポインタ
        DRIVE.w         ドライブ番号(0:カレント 1:A 2:B … 26:Z)
        SECT.{w/l}      読み込む最初のセクタ番号
        SECTLEN.{w/l}   読み込むセクタ数

        DRIVE で指定したブロックデバイスの、SECT で指定したセクタから、SECTLEN
        で指定したセクタ数だけ BUFFER で指定したバッファに読み込む。

        この DOS コールは、バッファのアドレス BUFFER をスタックに積む時
        [1] そのまま積む
        [2] BUFFER＋$80000000 を積む
        の二通りのコール方法があり、それぞれ引数の大きさが違う。

        [1] のそのまま積む方法の場合、SECT 及び SECTLEN はワードサイズで指定す
        る。この方法では、1 セクタ当りのバイト数が 1024 以外のドライブ(512 バ
        イトのドライブやリモートドライブなど)から読み込むことは出来ず、エラー
        になる。読み込みはセクタ単位で行うので、バッファはセクタ数×1024 バイ
        ト用意すること。

        [2] の BUFFER＋$80000000 を積む方法は大容量ドライブ・特殊ドライブのた
        めに用意されたもので、SECT 及び SECTLEN をロングワードサイズで指定する。
        こちらはセクタ当りのバイト数が 1024 でないドライブやリモートドライブか
        らも読み込めるが、1 セクタ当りのバイト数が 1024 とは限らないのでバッフ
        ァ容量には注意すること。

        いずれの方法でも、SECT は 0 以上、SECTLEN は 1 以上で、上限はメディア
        によって異なる。

[1]
        move    SECTLEN,-(sp)
        move    SECT,-(sp)
        move    DRIVE,-(sp)
        pea     (BUFFER)
        DOS     _DISKRED
        lea     (10,sp),sp

[2]
        move.l  SECTLEN,-(sp)
        move.l  SECT,-(sp)
        move    DRIVE,-(sp)
        pea     (BUFFER+$80000000)
        DOS     _DISKRED
        lea     (14,sp),sp

==============================================================================

$fff4   _DISKWRT        ブロックデバイスへ直接書き込む

引数    BUFFER.l        書き込むバッファのポインタ
        DRIVE.w         ドライブ番号(0:カレント 1:A 2:B … 26:Z)
        SECT.{w/l}      書き込む最初のセクタ番号
        SECTLEN.{w/l}   書き込むセクタ数

        BUFFER で指定したバッファから、DRIVE で指定したブロックデバイスの SECT
        で指定したセクタに、SECTLEN で指定したセクタ数だけ書き込む。

        この DOS コールは、バッファのアドレス BUFFER をスタックに積む時
        [1] そのまま積む
        [2] BUFFER＋$80000000 を積む
        の二通りのコール方法があり、それぞれ引数の大きさが違う。

        [1] のそのまま積む方法の場合、SECT 及び SECTLEN はワードサイズで指定す
        る。この方法では、1 セクタ当りのバイト数が 1024 以外のドライブ(512 バ
        イトのドライブやリモートドライブなど)に書き込むことは出来ず、エラーに
        なる。書き込みはセクタ単位で行うので、データはセクタ数×1024 バイトだ
        け用意しておくこと。

        [2] の BUFFER＋$80000000 を積む方法は大容量ドライブ・特殊ドライブのた
        めに用意されたもので、SECT 及び SECTLEN をロングワードサイズで指定する。
        こちらはセクタ当りのバイト数が 1024 でないドライブやリモートドライブに
        も書き込めるが、1 セクタ当りのバイト数が 1024 とは限らないので用意する
        データ量には注意すること。

        いずれの方法でも、SECT は 0 以上、SECTLEN は 1 以上で、上限はメディア
        によって異なる。

[1]
        move    SECTLEN,-(sp)
        move    SECT,-(sp)
        move    DRIVE,-(sp)
        pea     (BUFFER)
        DOS     _DISKWRT
        lea     (10,sp),sp

[2]
        move.l  SECTLEN,-(sp)
        move.l  SECT,-(sp)
        move    DRIVE,-(sp)
        pea     (BUFFER+$80000000)
        DOS     _DISKWRT
        lea     (14,sp),sp

==============================================================================

$fff5   _INDOSFLG       OS ワーク内へのポインタを得る

返値    INDOS_FLG のポインタ

    　OS のワーク INDOS_FLG へのポインタを返す。スーパーバイザ領域のため、ユー
    ザーモードではアクセス出来ない。また、INDOS_FLG 以後には OS にとって重要な
    ワークが存在するので、絶対に書き換えてはいけない。

    　INDOS_FLG の内容は以下の通り。

offset  size
0       1.w     indos_f         OS 実行中のレベル
2       1.b     doscmd          OS 実行中ファンクション番号
3       1.b     fat_flg         FAT 検索モード(0:標準 2:常に先頭から)
4       1.w     retry_count     I/O リトライ回数(標準で 3 回)
6       1.w     retry_time      リトライ待ち時間(標準で 100 = 1 秒)
8       1.w     verifyf         ベリファイモード(0:Off 1:On)
10      1.b     breakf          ブレークモード(0:Off 1:On)
11      1.b     ctrlpf          CTRL+P モード(0:Off 1:On)
12      1.b     (未公開)        スレッド切り換え要求フラグ
13      1.b     wkcurdrv        カレントドライブ(A=0,B=1,…,Z=25)

    　このファンクションコールの処理アドレスを変更することはできない(ベクタを
    書き換えても無視される)。

==============================================================================

$fff6   _SUPER_JSR      スーパーバイザモードでのプログラムのサブルーチンコール

引数    JOBADR.l        処理アドレス
        d0-d7/a0-a6     処理に依存

返値    d0-d7/a0-a6     処理に依存

    　JOBADR で指定したプログラムにスーパーバイザモードでサブルーチンコール
    (jsr)を行う。

    　DOS コールを実行する直前の d0-d7/a0-a6 が渡され、処理が戻るときにはその
    ときの d0-d7/a0-a6 が返るが、SR は変化しない。SSP/USP はどのように渡される
    か不定なので、スタックを用いて引数を渡すことはできない。

    　この DOS コールでは、jsr することにより発生する暴走やバスエラーに対する
    処理を全く行わない。

    　このファンクションコールの処理アドレスを変更することはできない(ベクタを
    書き換えても無視される)。

コード例
    pea (JOBADR)
    DOS _SUPER_JSR
    addq.l #4,sp

==============================================================================

$fff7   _BUS_ERR        バスエラーが発生するかの検査

引数    SIZE.w      アクセスサイズ(1:バイト 2:ワード 4:ロングワード)
        S_ADR.l     読み込みポインタ
        D_ADR.l     書き込みポインタ

返値    d0.l =  0   読み書き可能
        d0.l =  1   D_ADR に書き込んだときにバスエラーが発生
        d0.l =  2   S_ADR から読み込んだときにバスエラーが発生
        d0.l = -1   エラー(引数が不正)

    　SIZE で指定されたサイズで S_ADR で指定したアドレスから読み込み、そのデー
    タを D_ADR で指定したアドレスに書き込んでバスエラーが発生するかどうか調べ
    る。

    　SIZE の値が不正な場合は d0.l = -1 が返る。また SIZE = 2, 4 で S_ADR また
    は D_ADR に奇数アドレスを指定した場合も d0.l = -1 が返る。

    　このファンクションコールの処理アドレスを変更することはできない(ベクタを
    書き換えても無視される)。

コード例
    move SIZE,-(sp)
    pea (D_ADR)
    pea (S_ADR)
    DOS _BUS_ERR
    lea (10,sp),sp

==============================================================================

$fff8   _OPEN_PR        バックグラウンドタスクの登録

引数    NAME.l          スレッド名のポインタ
        COUNT.w         実行間隔を決める値
        INIT_USP.l      USP の初期値
        INIT_SSP.l      SSP の初期値
        INIT_SR.w       SR の初期値
        INIT_PC.l       プログラムの実行アドレス
        BUFFER.l        タスク間通信バッファのポインタ
        SLEEP_TIME.l    待ち時間(ms)

返値    登録したタスクのスレッド ID(負数ならエラーコード)
                d0.l = -27      既に同名タスクが存在する。
                d0.l = -29      これ以上タスクを登録出来ない。

    　NAME で指定した 15 文字以内のスレッド名のバックグラウンドタスクを登録す
    る。登録したスレッドはスリープ状態になる。

    　COUNT には、タスクを 1 回実行するのにタイマ割り込みを何回カウントするか
    の回数を 2～255 で指定する。0～1 の場合は 2 として扱う。

    　INIT_USP、INIT_SSP、INIT_PC は登録したタスクを実行する時のそれぞれのレ
    ジスタの初期値。システム用のスタックは 6KB 必要。

    　INIT_SR は$0000(ユーザーモード)または$2000(スーパーバイザーモード)のどち
    らかを指定する。

    　その他のレジスタの初期値は全て 0。

    　BUFFER はタスク間通信のバッファのアドレスを指定する。

    　SLEEP_TIME は待ち時間をミリ秒単位で指定する。0 を指定すると永久にスリー
    プする。

    　DOS _OPEN_PR によりバックグラウンドタスクとして登録されたスレッドは、DOS
    _KEEPPR で常駐終了する。スレッドをメモリ上から消去する場合は DOS _KILL_PR
    を使用する。

    　BUFFER の内容は以下の通り。

offset  size
0       1.l     LENGTH  データ用バッファのバイト数
4       1.l     DATABUF データ用バッファの先頭アドレス
8       1.w     COMMNAD コマンド番号
10      1.w     ID      相手の ID(-1 で通信許可)

    　このファンクションコールの処理アドレスを変更する(ベクタを書き換える)と、
    Human68k 本来の処理が正常終了した後に設定したアドレスが実行される。

コード例
    move.l SLEEP_TIME,-(sp)
    pea (BUFFER)
    pea (INIT_PC)
    move INIT_SR,-(sp)
    pea (INIT_SSP)
    pea (INIT_USP)
    move COUNT,-(sp)
    pea (NAME)
    DOS _OPEN_PR
    lea (28,sp),sp

==============================================================================

$fff9   _KILL_PR        自分自身のプロセスの削除

返値    エラーコード

    　自分自身のプロセスを削除する。常駐終了していたプロセスの場合、同じプロセ
    ス ID を持つスレッド全てを削除し、確保されていたメモリを解放する。

    　この DOS コールを実行する前には、自分でオープンしたファイルは全てクロー
    ズし、書き換えたベクタなども元に戻す。システムはスレッドの削除とメモリの解
    放しか行わない。

    　プロセス内でいくつかの登録したスレッドを実行した後で DOS _EXIT や DOS
    _EXIT2 で終了する場合、先にオープンしたスレッドを KILL_PR で削除する。メイ
    ンのスレッドであるプロセスを削除した場合、その後の動作は保証されない。自分
    以外のプロセスを削除する場合は、DOS _SEND_PR で KILL コマンドを送る。

    　このファンクションコールの処理アドレスを変更する(ベクタを書き換える)と、
    Human68k 本来の処理が行われた後に、一つのスレッドを削除するごとに設定した
    アドレスが実行される。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    　スレッドをオープンしたプロセスが DOS _KEEPPR で常駐終了するまえに DOS
    _KILL_PR を実行すると、実行中のプロセスのメモリが解放されてしまい、解放さ
    れたメモリ上のコードが実行されてしまう。

不具合
    該当環境: Human68k v3.02 (これ以外は未調査)
    　オープンしたスレッドから DOS _EXEC で実行された子プロセス内でスレッドの
    切り替えが起きてから DOS _EXIT などで終了し、もとのプロセスに制御が戻った
    直後に DOS _KILL_PR を実行すると、プロセスのメモリは解放されるがスレッドが
    削除されず、解放されたメモリ上のコードが実行されてしまう。

==============================================================================

$fffa   _GET_PR         スレッドの管理情報を得る

引数    ID.w            スレッド ID
        BUFFER.l        管理情報を書き込むバッファのポインタ

返値    スレッド ID 若しくはエラーコード

    　指定された ID のスレッドの管理情報を、BUFFER で指定した 116 バイトのバッ
    ファに複写する。

    　ID に -1 を指定し、BUFFER+96 にスレッドの名前を指定すると、スレッドの ID
    が返る。また、ID に -2 を指定すると、自分自身の ID が返る。

    　このファンクションコールの処理アドレスを変更することはできない(ベクタを
    書き換えても無視される)。

offset  size
0       1.l     NEXT_PTR        次のスレッドの管理情報格納領域
4       1.b     WAIT_FLG        0:Normal -1:Wait
5       1.b     COUNT           減算カウンタ
6       1.b     MAX_CNT         COUNT の初期値
7       1.b     DOSCMD          DOS コール番号
8       1.l     PSP_ID          プロセス ID
12      1.l     USP
16      8.l     D0,D1,D2,D3,D4,D5,D6,D7
48      7.l     A0,A1,A2,A3,A4,A5,A6
76      1.w     SR
78      1.l     PC
82      1.l     SSP
86      1.w     INDOSF          システム予約(OS 実行中レベル)
88      1.l     INDOSP          システム予約(OS 実行中スタック)
92      1.l     BUFF            タスク間通信バッファ
96      16.b                    スレッドの名前
112     1.l     WAIT_TIME       待ち時間の残り(ミリ秒)

    　実際の管理情報の大きさは 124 バイトであるが、そのうち先頭から 116 バイト
    だけが得られる。

コード例
    pea (BUFFER)
    move ID,-(sp)
    DOS _GET_PR
    addq.l  #6,sp

==============================================================================

$fffb   _SUSPEND_PR     スレッドを強制的にスリープ状態にする

引数    ID.w            スレッド ID

返値    エラーコード
                d0.l = 0                正常終了
                d0.l < 0                エラーコード
                d0.l = -1               スレッド自身のエラー
                d0.l = $ffff00??        ID が異常($?? は ID の最大値)

    　ID で指定したスレッドを強制的にスリープ状態にする。スリープ状態になった
    スレッドは、DOS _SEND_PR で起こされるまでスリープする。

    　このファンクションコールの処理アドレスを変更することはできない(ベクタを
    書き換えても無視される)。

    　なお、XC の DOSCALL.MAC では _SUSPEND というシンボル名で定義されている。
    プログラマーズマニュアルの記載は _SUSPEND_PR、C言語用の関数(DOSLIB)は
    SUSPEND_PR() であるので、_SUSPEND_PR が正しいシンボル名と思われる。

コード例
    move ID,-(sp)
    DOS _SUSPEND_PR
    addq.l #2,sp

==============================================================================

$fffc   _SLEEP_PR       スリープ状態に入る

引数    TIME.l          待ち時間(ミリ秒単位)

返値    スレッドの状態
                d0.l = -1       待ち時間が経過し、自分で起きた。
                d0.l = -2       待ち時間が経過した後 DOS _SEND_PR で起こされた。
                d0.l = その他   残り時間(DOS _SEND_PR で起こされた)。

    　TIME で待ち時間を指定してスリープ状態に入る。
    　TIME = 0 の時、永久にスリープする。

    　スリープ状態に入ったスレッドは DOS _SEND_PR を用いて強制的に起こすことが
    できる。DOS _SEND_PR のコマンドが $fffb の場合、タスク間通信バッファは変化
    しない。それ以外のコマンドの場合は、以下の通りに設定される。

offset  size
0       1.l     LENGTH  データバッファに書き込まれたバイト数
4       1.l     DATABUF データバッファのポインタ
8       1.w     COMMAND コマンド番号
10      1.w     ID      起こしたスレッドの ID

    　スリープする前にデータバッファの内容を処理してからデータバッファのアドレ
    スとバイト数を設定し、ID に -1 を設定する。これにより、他のスレッドからの
    通信を許可することになる。スリープしていない時でも SEND_PR によりデータが
    送られた場合は、スリープするとすぐに起こされ設定した待ち時間を返す。

    　返値の内容は以下の通り。

        d0.l = -1
            待ち時間が経過して自分で起きた。
            タスク間通信バッファの内容は変化しない。
        d0.l = -2
            待ち時間が経過したが、DOS _SUSPEND_PR で止められた後 DOS _SEND_PR
            で起こされた。
        d0.l = その他
            待ち時間は経過していないが、DOS _SEND_PR で起こされた。
            返値の単位はミリ秒。

    　このファンクションコールの処理アドレスを変更することはできない(ベクタを
    書き換えても無視される)。

コード例
    move.l TIME,-(sp)
    DOS _SLEEP_PR
    addq.l #4,sp

==============================================================================

$fffd   _SEND_PR        スレッドにコマンド/データを送り、スリープしていたら起こす

引数    MY_ID.w         自分のスレッド ID
        YOUR_ID.w       相手のスレッド ID
        CMDNO.w         送出するコマンド
        BUFFER.l        送出するデータのポインタ
        LEN.l           送出するデータのバイト数

返値    d0.l = 0                正常終了
        d0.l < 0                エラーコード
        d0.l = -28              書き込みエラー
        d0.l = $ffff00??        指定 ID が不正($?? は ID の最大値)
        d0.l = $8000????        データのバイト数が不正($???? は容量の最大値)

    　指定した ID のスレッドにコマンドやデータを送り、スリープしていたら起こす。
    　MY_ID に自分の ID、YOUR_ID に通信先のスレッドの ID を指定する。
    　CMDNO は通信の内容を表すワード値で、システムで定められているコマンド以外
    はそれぞれのスレッド間で定義する。システムで予約しているコマンドは $ff??
    で、以下に示す値が定義されている。

        $fff9   スレッドを消去するように要求する。
        $fffb   強制スリープ状態から起こすだけで、タスク間通信バッファは変化しない。
        $fffc   スリープするように要求する。
                起こされた時にこのコマンドが送られていたら、すぐにタスク間通信
                バッファの ID を -1 にしてスリープするべきである。
                スリープしないでタスク間通信バッファを監視している場合に有効。
        $ffff   処理が終ったかどうか調べる。-28 が返れば、まだ処理中である。

    　コマンドやデータの転送には、タスク間通信バッファが使用される。バッファの
    内容は以下の通り。

offset  size
0       1.l     LENGTH  データバッファのバイト数
4       1.l     DATABUF データバッファのポインタ
8       1.w     COMMAND コマンド番号
10      1.w     ID      ID(-1 で通信許可)

    　YOUR_ID で指定したスレッドの、タスク間通信バッファの ID が -1 に設定され
    ていたら、そのバッファは書き込み可能なので、MY_ID と CMDNO をそれぞれ ID
    と COMMAND に設定し、BUFFER からのデータを LEN で指定したバイト数だけ
    DATABUF に書き込み、LENGTH を LEN にする。また、指定したスレッドがスリープ
    していたら起こす。

    　特に $fffb のコマンドは特殊処理され、指定したスレッドを起こすだけでタス
    ク間通信バッファの ID が -1 でなくてもよく、その他のバッファも変化しない。

    　LEN が LENGTH より大きい時や書き込み不可の時はエラーになる。

    　このファンクションコールの処理アドレスを変更することはできない(ベクタを
    書き換えても無視される)。

コード例
    move.l LEN,-(sp)
    pea (BUFFER)
    move CMDNO,-(sp)
    move YOUR_ID,-(sp)
    move MY_ID,-(sp)
    DOS _SEND_PR
    lea (14,sp),sp

==============================================================================

$fffe   _TIME_PR        タイマのカウンタ値を得る

返値    現在のタイマのカウンタ値

    　現在のタイマのカウンタ値(ミリ秒単位)を調べる。

    　バックグラウンドで複数のスレッドが平行して動作している場合、プログラムで
    一定の時間を計るためには、どのスレッドが動作していても一定して変化するカウ
    ンタが必要になる。ロングワードでの最大値を越えると 0 に戻るので、そのまま
    前回に返された値との減算で経過時間が分かる。

    　このファンクションコールの処理アドレスを変更することはできない(ベクタを
    書き換えても無視される)。

==============================================================================

$ffff   _CHANGE_PR      実行権を放棄

    　バックグラウンドタスクの自分の実行権を放棄する。次のタスクに切り換わる。

    　このファンクションコールの処理アドレスを変更する(ベクタを書き換える)と、
    Human68k 本来の処理が正常終了した後に設定したアドレスが実行される。

==============================================================================
