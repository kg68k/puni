        - FE FUNCTION CALL MANUAL -

==============================================================================

・FE コール一覧

$fe00  __LMUL       signed int 乗算             d0 *= d1
$fe01  __LDIV       signed int 除算             d0 /= d1
$fe02  __LMOD       signed int 除算の剰余       d0 %= d1
$fe04  __UMUL       unsigned int 乗算           d0 *= d1
$fe05  __UDIV       unsigned int 除算           d0 /= d1
$fe06  __UMOD       unsigned int 除算の剰余     d0 %= d1
$fe08  __IMUL       unsigned int 乗算           d0:d1 = d0*d1
$fe09  __IDIV       unsigned int 除算           d0...d1 = d0/d1
$fe0c  __RANDOMIZE  signed short 乱数初期化     seed = d0(-32768～32767)
$fe0d  __SRAND      unsigned short 乱数初期化   seed = d0(0～65535)
$fe0e  __RAND       signed int 乱数             d0 = rand()

$fe10  __STOL       10進文字列 → signed int    d0 = (a0)～
$fe11  __LTOS       signed int → 10進文字列    (a0)～ = d0
$fe12  __STOH       16進文字列 → unsigned int  d0 = (a0)～
$fe13  __HTOS       unsigned int → 16進文字列  (a0)～ = d0
$fe14  __STOO       8進文字列 → unsigned int   d0 = (a0)～
$fe15  __OTOS       unsigned int → 8進文字列   (a0)～ = d0
$fe16  __STOB       2進文字列 → unsigned int   d0 = (a0)～
$fe17  __BTOS       unsigned int → 2進文字列   (a0)～ = d0
$fe18  __IUSING     signed int → 10進文字列    (a0)～ = d0,d1桁
$fe1a  __LTOD       signed int → double        d0:d1 = d0
$fe1b  __DTOL       double → signed int        d0 = d0:d1
$fe1c  __LTOF       signed int → float         d0 = d0
$fe1d  __FTOL       float → signed int         d0 = d0
$fe1e  __FTOD       float → double             d0:d1 = d0
$fe1f  __DTOF       double → float             d0 = d0:d1

$fe20  __VAL        文字列 → double            d0:d1 = (a0)～
$fe21  __USING      double → 10進文字列        (a0)～ = d0:d1,d2.d3,d4
$fe22  __STOD       10進文字列 → double        d0:d1,d2,d3 = (a0)～
$fe23  __DTOS       double → 10進文字列        (a0)～ = d0:d1
$fe24  __ECVT       double → 文字列            (a0),d0,d1 = d0:d1,d2全体桁
$fe25  __FCVT       double → 文字列            (a0),d0,d1 = d0:d1,d2小数点桁
$fe26  __GCVT       double → 文字列            (a0)～ = d0:d1,d2全体桁
$fe28  __DTST       double 0 比較               Z,N = d0:d1
$fe29  __DCMP       double 比較                 Z,C = d0:d1-d2:d3
$fe2a  __DNEG       double 符号反転             d0:d1 = neg(d0:d1)
$fe2b  __DADD       double 加算                 d0:d1 += d2:d3
$fe2c  __DSUB       double 減算                 d0:d1 -= d2:d3
$fe2d  __DMUL       double 乗算                 d0:d1 *= d2:d3
$fe2e  __DDIV       double 除算                 d0:d1 /= d2:d3
$fe2f  __DMOD       double 除算の剰余           d0:d1 %= d2:d3
$fe30  __DABS       double 絶対値               d0:d1 = abs(d0:d1)
$fe31  __DCEIL      double 小数切上             d0:d1 = ceil(d0:d1)
$fe32  __DFIX       double 整数部               d0:d1 = fix(d0:d1)
$fe33  __DFLOOR     double 小数切捨             d0:d1 = floor(d0:d1)
$fe34  __DFRAC      double 小数部               d0:d1 = frac(d0:d1)
$fe35  __DSGN       double 正負零               d0:d1 = sgn(d0:d1)
$fe36  __SIN        double 正弦                 d0:d1 = sin(d0:d1)
$fe37  __COS        double 余弦                 d0:d1 = cos(d0:d1)
$fe38  __TAN        double 正接                 d0:d1 = tan(d0:d1)
$fe39  __ATAN       double 逆正接               d0:d1 = atan(d0:d1)
$fe3a  __LOG        double 自然対数             d0:d1 = ln(d0:d1)
$fe3b  __EXP        double 指数関数             d0:d1 = exp(d0:d1)
$fe3c  __SQR        double 平方根               d0:d1 = sqr(d0:d1)
$fe3d  __PI         double 円周率               d0:d1 = pi()
$fe3e  __NPI        double 円周率乗算           d0:d1 = pi(d0:d1)
$fe3f  __POWER      double 羃乗                 d0:d1 = pow(d0:d1,d2:d3)
$fe40  __RND        double 乱数                 d0:d1 = rnd()
$fe41  __SINH       double 双曲正弦             d0:d1 = sinh(d0:d1)
$fe42  __COSH       double 双曲余弦             d0:d1 = cosh(d0:d1)
$fe43  __TANH       double 双曲正接             d0:d1 = tanh(d0:d1)
$fe44  __ATANH      double 双曲逆正接           d0:d1 = atanh(d0:d1)
$fe45  __ASIN       double 逆正弦               d0:d1 = asin(d0:d1)
$fe46  __ACOS       double 逆余弦               d0:d1 = acos(d0:d1)
$fe47  __LOG10      double 常用対数             d0:d1 = log10(d0:d1)
$fe48  __LOG2       double 対数(底2)            d0:d1 = log2(d0:d1)
$fe49  __DFREXP     double 仮数指数分割         d0:d1,d2 = d0:d1
$fe4a  __DLDEXP     double 仮数指数結合         d0:d1 = d0:d1,d2
$fe4b  __DADDONE    double 1 加算               d0:d1 += 1.0
$fe4c  __DSUBONE    double 1 減算               d0:d1 -= 1.0
$fe4d  __DDIVTWO    double 2 除算               d0:d1 /= 2.0
$fe4e  __DIEECNV    double SHARP → IEEE        d0:d1 = d0:d1
$fe4f  __IEEDCNV    double IEEE → SHARP        d0:d1 = d0:d1

$fe50  __FVAL       文字列 → float             d0 = (a0)～
$fe51  __FUSING     float → 10進文字列         (a0)～ = d0,d2.d3,d4
$fe52  __STOF       10進文字列 → float         d0,d2,d3 = (a0)～
$fe53  __FTOS       float → 10進文字列         (a0)～ = d0
$fe54  __FECVT      float → 文字列             (a0),d0,d1 = d0,d2全体桁
$fe55  __FFCVT      float → 文字列             (a0),d0,d1 = d0,d2小数点桁
$fe56  __FGCVT      float → 文字列             (a0)～ = d0,d2全体桁
$fe58  __FTST       float 0 比較                Z,N = d0
$fe59  __FCMP       float 比較                  Z,C = d0-d1
$fe5a  __FNEG       float 符号反転              d0 = neg(d0)
$fe5b  __FADD       float 加算                  d0 += d1
$fe5c  __FSUB       float 減算                  d0 -= d1
$fe5d  __FMUL       float 乗算                  d0 *= d1
$fe5e  __FDIV       float 除算                  d0 /= d1
$fe5f  __FMOD       float 除算の剰余            d0 %= d1
$fe60  __FABS       float 絶対値                d0 = abs(d0)
$fe61  __FCEIL      float 小数切上              d0 = ceil(d0)
$fe62  __FFIX       float 整数部                d0 = fix(d0)
$fe63  __FFLOOR     float 小数切捨              d0 = floor(d0)
$fe64  __FFRAC      float 小数部                d0 = frac(d0)
$fe65  __FSGN       float 正負零                d0 = sgn(d0)
$fe66  __FSIN       float 正弦                  d0 = sin(d0)
$fe67  __FCOS       float 余弦                  d0 = cos(d0)
$fe68  __FTAN       float 正接                  d0 = tan(d0)
$fe69  __FATAN      float 逆正接                d0 = atan(d0)
$fe6a  __FLOG       float 自然対数              d0 = ln(d0)
$fe6b  __FEXP       float 指数関数              d0 = exp(d0)
$fe6c  __FSQR       float 平方根                d0 = sqr(d0)
$fe6d  __FPI        float 円周率                d0 = pi()
$fe6e  __FNPI       float 円周率乗算            d0 = pi(d0)
$fe6f  __FPOWER     float 羃乗                  d0 = pow(d0,d1)
$fe70  __FRND       float 乱数                  d0 = rnd()
$fe71  __FSINH      float 正弦                  d0 = sinh(d0)
$fe72  __FCOSH      float 双曲余弦              d0 = cosh(d0)
$fe73  __FTANH      float 双曲正接              d0 = tanh(d0)
$fe74  __FATANH     float 双曲逆正接            d0 = atanh(d0)
$fe75  __FASIN      float 逆正弦                d0 = asin(d0)
$fe76  __FACOS      float 逆余弦                d0 = acos(d0)
$fe77  __FLOG10     float 常用対数              d0 = log10(d0)
$fe78  __FLOG2      float 対数(底2)             d0 = log2(d0)
$fe79  __FFREXP     float 仮数指数分割          d0,d1 = d0
$fe7a  __FLDEXP     float 仮数指数結合          d0 = d0,d1
$fe7b  __FADDONE    float 1 加算                d0 += 1.0
$fe7c  __FSUBONE    float 1 減算                d0 -= 1.0
$fe7d  __FDIVTWO    float 2 除算                d0 /= 2.0
$fe7e  __FIEECNV    float SHARP → IEEE         d0 = d0
$fe7f  __IEEFCNV    float IEEE → SHARP         d0 = d0

$fee0  __CLMUL      signed int 乗算             (sp) *= (4,sp)
$fee1  __CLDIV      signed int 除算             (sp) /= (4,sp)
$fee2  __CLMOD      signed int 除算の剰余       (sp) %= (4,sp)
$fee3  __CUMUL      unsigned int 乗算           (sp) *= (4,sp)
$fee4  __CUDIV      unsigned int 除算           (sp) /= (4,sp)
$fee5  __CUMOD      unsigned int 除算の剰余     (sp) %= (4,sp)
$fee6  __CLTOD      signed int → double        (sp):(4,sp) = (sp)
$fee7  __CDTOL      double → signed int        (sp) = (sp):(4,sp)
$fee8  __CLTOF      signed int → float         (sp) = (sp)
$fee9  __CFTOL      float → signed int         (sp) = (sp)
$feea  __CFTOD      float → double             (sp):(4,sp) = (sp)
$feeb  __CDTOF      double → float             (sp) = (sp):(4,sp)
$feec  __CDCMP      double 比較                 Z,C = (sp):(4,sp)-(8,sp):(12,sp)
$feed  __CDADD      double 加算                 (sp):(4,sp) += (8,sp):(12,sp)
$feee  __CDSUB      double 減算                 (sp):(4,sp) -= (8,sp):(12,sp)
$feef  __CDMUL      double 乗算                 (sp):(4,sp) *= (8,sp):(12,sp)
$fef0  __CDDIV      double 除算                 (sp):(4,sp) /= (8,sp):(12,sp)
$fef1  __CDMOD      double 除算の剰余           (sp):(4,sp) %= (8,sp):(12,sp)
$fef2  __CFCMP      float 比較                  Z,C = (sp)-(4,sp)
$fef3  __CFADD      float 加算                  (sp) += (4,sp)
$fef4  __CFSUB      float 減算                  (sp) -= (4,sp)
$fef5  __CFMUL      float 乗算                  (sp) *= (4,sp)
$fef6  __CFDIV      float 除算                  (sp) /= (4,sp)
$fef7  __CFMOD      float 除算の剰余            (sp) %= (4,sp)
$fef8  __CDTST      double 0 比較               Z,N = (sp):(4,sp)
$fef9  __CFTST      float 0 比較                Z,N = (sp)
$fefa  __CDINC      double 1 加算               (sp):(4,sp) += 1.0
$fefb  __CFINC      float 1 加算                (sp) += 1.0
$fefc  __CDDEC      double 1 減算               (sp):(4,sp) -= 1.0
$fefd  __CFDEC      float 1 減算                (sp) -= 1.0

$fefe  __FEVARG     数値演算ドライバ種別検査    d0,d1 = [FORMAT],[MODE]
$feff  __FEVECS     処理アドレス変更            d0 = intvcs(d0,a0)

==============================================================================

・浮動小数点データ形式

・SHARP フォーマット(FLOAT1.X でのみ使用)

単精度(32bit)
        | 31 | 30 29 …  9  8 |  7  6 …  1  0 |
        | ↑ |  仮数部 23bit  |  指数部  8bit  |
          仮数部の符号

倍精度(64bit)
        | 63 | 62 61 … 12 11 | 10  9 …  1  0 |
        | ↑ |  仮数部 52bit  |  指数部 11bit  |
          仮数部の符号

・IEEE フォーマット

単精度(32bit)
        | 31 | 30 29 … 24 23 | 22 21 …  1  0 |
        | ↑ |  指数部  8bit  |  仮数部 23bit  |
          仮数部の符号

倍精度(64bit)
        | 63 | 62 61 … 53 52 | 51 50 …  1  0 |
        | ↑ |  指数部 11bit  |  仮数部 52bit  |
          仮数部の符号

仕様                単精度              倍精度
正規化数の表現      -1s*1.f*2^(e-127)   -1s*1.f*2^(e-1023)
非正規化数の表現    -1s*0.f*2^(e-126)   -1s*0.f*2^(e-1022)
表現可能な数の絶対値(概数)
正規化数最大値      3.4*10^38           1.8*10^307
正規化数最小値      1.2*10^(-38)        2.2*10^(-308)
非正規化数最小値    1.4*10^(-45)        4.9*10^(-324)
    (s:仮数部の符号,f:仮数部,e:指数部)

・実際の表現方法

　実数を ±(1.mmmm‥‥)*2^(±eeee‥‥) と表わす。そのとき先頭の符号が仮数部の
符号、mmmm‥‥ が仮数となる。指数部は単精度で (±eeee‥‥)+$7F、倍精度で
(±eeee‥‥)+$3ff を与える。これはそれぞれ 1～$fe、1～$7fe の範囲でなければな
らない。

　演算の結果、指数が最大で仮数が0ならば±∞を表わす(符号は MSB による)。また、
指数が最大で仮数が0以外ならば非数を表わす。指数・仮数ともに0の場合は、数値0を
表わす。

特殊な実数データのフォーマット
        指数            仮数
 最小値<指数<最大値     任意のビットパターン            正規化数(通常)
        0               オール0以外の任意のパターン     非正規化数
                                                    (アンダフロー限界付近の値)
        0               0                               零
        最大値          0                               無限大
        最大値          オール0以外の任意のパターン     NaN(Not A Number)

・非数及び無限大の文字列表現

非数    '#NAN','-#NAN'
無限大  '#INF','-#INF'


なお、演算においてエラーが起きた場合、返値は不定となる。

==============================================================================

$fe00  __LMUL       signed int 乗算             d0 *= d1

引数    d0.l    被乗数
        d1.l    乗数

返値    d0.l    演算結果(オーバーフロー時は不定)

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット
        Z : (C = 1)オーバーフローの場合はクリア

        ロングワード符号付き整数同士の乗算を行なう。
        演算結果がロングワード符号付き整数の範囲を超えた場合はエラーとなる。

不具合  参考: http://retropc.net/x68000/data/fefunc/l/lmul/

==============================================================================

$fe01  __LDIV       signed int 除算             d0 /= d1

引数    d0.l    被除数
        d1.l    除数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、ゼロ除算の場合はクリア
        Z : (C = 1)ゼロ除算の場合はセット、オーバーフローの場合はクリア

        ロングワード符号付き整数同士の除算を行なう。
        除数が 0 の場合はエラーとなる。

不具合  参考: http://retropc.net/x68000/data/fefunc/l/ldiv/

==============================================================================

$fe02  __LMOD       signed int 除算の剰余       d0 %= d1

引数    d0.l    被除数
        d1.l    除数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)ゼロ除算の場合はクリア
        Z : (C = 1)ゼロ除算の場合はセット

        ロングワード符号付き整数同士の除算の剰余を計算する。
        除数が 0 の場合はエラーとなる。

不具合  参考: http://retropc.net/x68000/data/fefunc/l/lmod/

==============================================================================

$fe04  __UMUL       unsigned int 乗算           d0 *= d1

引数    d0.l    被乗数
        d1.l    乗数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット
        Z : (C = 1)オーバーフローの場合はクリア

        ロングワード符号なし整数同士の乗算を行なう。
        演算結果がロングワード符号なし整数の範囲を超えた場合はエラーとなる。

不具合  参考: http://retropc.net/x68000/data/fefunc/u/umul/

==============================================================================

$fe05  __UDIV       unsigned int 除算           d0 /= d1

引数    d0.l    被除数
        d1.l    除数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)ゼロ除算の場合はクリア
        Z : (C = 1)ゼロ除算の場合はセット

        ロングワード符号なし整数同士の除算を行なう。
        除数が 0 の場合はエラーとなる。

不具合  参考: http://retropc.net/x68000/data/fefunc/u/udiv/

==============================================================================

$fe06  __UMOD       unsigned int 除算の剰余     d0 %= d1

引数    d0.l    被除数
        d1.l    除数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)ゼロ除算の場合はクリア
        Z : (C = 1)ゼロ除算の場合はセット

        ロングワード符号なし整数同士の除算の剰余を計算する。
        除数が 0 の場合はエラーとなる。

不具合  参考: http://retropc.net/x68000/data/fefunc/u/umod/

==============================================================================

$fe08  __IMUL       unsigned int 乗算           d0:d1 = d0*d1

引数    d0.l    被乗数
        d1.l    乗数

返値    d0.l    演算結果の上位 4 バイト
        d1.l    〃        下位 〃

        ロングワード符号なし整数同士の乗算を行なう。
        演算結果は 64 ビットまで対応しているので、エラーは発生しない。

==============================================================================

$fe09  __IDIV       unsigned int 除算           d0...d1 = d0/d1

引数    d0.l    被除数
        d1.l    除数

返値    d0.l    演算結果(商)
        d1.l    〃      (剰余)

CCR     C : エラーの時セット

        ロングワード符号なし整数同士の除算を行なう。
        除数が 0 の場合はエラーとなる。

==============================================================================

$fe0c  __RANDOMIZE  signed short 乱数初期化     seed = d0(-32768～32767)

引数    d0.l    ランダム・シード

破壊    d0.l

        -32,768～32,767 の範囲でランダム・シードを与え、乱数を初期化する。
        引数の上位ワードは無視され、d0.l の値が範囲外であっても下位ワードだけ
        が参照されて常に初期化が行われる。

==============================================================================

$fe0d  __SRAND      unsigned short 乱数初期化   seed = d0(0～65535)

引数    d0.l    ランダム・シード

破壊    d0.l

        0～65,535 の範囲でランダム・シードを与え、乱数を初期化する。
        引数の上位ワードは無視され、d0.l の値が範囲外であっても下位ワードだけ
        が参照されて常に初期化が行われる。

==============================================================================

$fe0e  __RAND       signed int 乱数             d0 = rand()

返値    d0.l    乱数(0～32,767)

        ロングワード符号付き整数の乱数を返す。

==============================================================================

$fe10  __STOL       10進文字列 → signed int    d0 = (a0)～

引数    a0.l    文字列のアドレス

返値    d0.l    変換されたロングワード符号付き整数
        a0.l    数値の末尾桁の次のアドレス

CCR     C : エラーの時セット
        N : (C = 1)数値の記述法がおかしい場合セット
        V : (C = 1)オーバーフローが発生した場合セット

        文字列をロングワード符号付き整数に変換する。

==============================================================================

$fe11  __LTOS       signed int → 10進文字列    (a0)～ = d0

引数    d0.l    ロングワード符号付き整数
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

        ロングワード符号付き整数を文字列に変換する。

==============================================================================

$fe12  __STOH       16進文字列 → unsigned int  d0 = (a0)～

引数    a0.l    文字列のアドレス

返値    d0.l    変換されたロングワード符号なし整数
        a0.l    数値の末尾桁の次のアドレス

CCR     C : エラーの時セット
        N : (C = 1)数値の記述法がおかしい場合セット
        V : (C = 1)オーバーフローが発生した場合セット

        16進数を表わす文字列をロングワード符号なし整数に変換する。

==============================================================================

$fe13  __HTOS       unsigned int → 16進文字列  (a0)～ = d0

引数    d0.l    ロングワード符号なし整数
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

        ロングワード符号なし整数を16進数表現の文字列に変換する。

==============================================================================

$fe14  __STOO       8進文字列 → unsigned int   d0 = (a0)～

引数    a0.l    文字列のアドレス

返値    d0.l    変換されたロングワード符号なし整数
        a0.l    数値の末尾桁の次のアドレス

CCR     C : エラーの時セット
        N : (C = 1)数値の記述法がおかしい場合セット
        V : (C = 1)オーバーフローが発生した場合セット

        ８進数を表わす文字列をロングワード符号なし整数に変換する。

==============================================================================

$fe15  __OTOS       unsigned int → 8進文字列   (a0)～ = d0

引数    d0.l    ロングワード符号なし整数
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

        ロングワード符号なし整数を８進数表現の文字列に変換する。

==============================================================================

$fe16  __STOB       2進文字列 → unsigned int   d0 = (a0)～

引数    a0.l    文字列のアドレス

返値    d0.l    変換されたロングワード符号なし整数
        a0.l    数値の末尾桁の次のアドレス

CCR     C : エラーの時セット
        N : (C = 1)数値の記述法がおかしい場合セット
        V : (C = 1)オーバーフローが発生した場合セット

        ２進数を表わす文字列をロングワード符号なし整数に変換する。

==============================================================================

$fe17  __BTOS       unsigned int → 2進文字列   (a0)～ = d0

引数    d0.l    ロングワード符号なし整数
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

        ロングワード符号なし整数を２進数表現の文字列に変換する。

==============================================================================

$fe18  __IUSING     signed int → 10進文字列    (a0)～ = d0,d1桁

引数    d0.l    ロングワード符号付き整数
        d1.l    桁数
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

        ロングワード符号付き整数を文字列に変換する。変換後の文字列が指定した桁
        数に満たない場合は、ゼロ・サプレスを行った後で右詰めにして返す。
        指定桁数より文字列が長くなる場合は、桁数を無視して必要なだけの長さの文
        字列を返す。

==============================================================================

$fe1a  __LTOD       signed int → double        d0:d1 = d0

引数    d0.l    ロングワード符号付き整数

返値    d0:d1   変換された倍精度浮動小数点数

        ロングワード符号付き整数を倍精度浮動小数点数に変換する。

==============================================================================

$fe1b  __DTOL       double → signed int        d0 = d0:d1

引数    d0:d1   倍精度浮動小数点数

返値    d0.l    変換されたロングワード符号付き整数

CCR     C : エラーの時セット

        倍精度浮動小数点数をロングワード符号付き整数に変換する。小数部は切り捨
        てられる。
        変換結果がロングワード符号付き整数の範囲を超えた場合はエラーとなる。

==============================================================================

$fe1c  __LTOF       signed int → float         d0 = d0

引数    d0.l    ロングワード符号付き整数

返値    d0.l    変換された単精度浮動小数点数

        ロングワード符号付き整数を単精度浮動小数点数に変換する。

==============================================================================

$fe1d  __FTOL       float → signed int         d0 = d0

引数    d0.l    単精度浮動小数点数

返値    d0.l    変換されたロングワード符号付き整数

CCR     C : エラーの時セット

        単精度浮動小数点数をロングワード符号付き整数に変換する。小数部は切り捨
        てられる。
        変換結果がロングワード符号付き整数の範囲を超えた場合はエラーとなる。

==============================================================================

$fe1e  __FTOD       float → double             d0:d1 = d0

引数    d0.l    単精度浮動小数点数

返値    d0:d1   変換された倍精度浮動小数点数

        単精度浮動小数点数を倍精度浮動小数点数に変換する。

==============================================================================

$fe1f  __DTOF       double → float             d0 = d0:d1

引数    d0:d1   倍精度浮動小数点数

返値    d0.l    変換された単精度浮動小数点数

CCR     C : エラーの時セット

        倍精度浮動小数点数を単精度浮動小数点数に変換する。
        変換できなかった場合はエラーとなる。

==============================================================================

$fe20  __VAL        文字列 → double            d0:d1 = (a0)～

引数    a0.l    文字列のアドレス

返値    d0:d1   変換された倍精度浮動小数点数
        d2.w    整数フラグ(文字列が10進数だった場合に有効)
        d3.l    整数値    (〃)
        a0.l    数値の末尾桁の次のアドレス

CCR     C : エラーの時セット
        N : (C = 1)数値の記述法がおかしい場合セット
        V : (C = 1)オーバーフローが発生した場合セット

        文字列を倍精度浮動小数点数に変換する。文字列の先頭に"&H","&O","&B"がつ
        いていている場合は、それぞれ16,8,2進数で表現されているものと扱う。
        文字列が10進数だった場合、返値として d2,d3 が有効になる。文字列が整数
        でかつロングワード符号付き整数で表現可能な場合、整数フラグ d2 は -1 に
        なり d3 にはその整数値が入る。それ以外の場合は d2 = 0 になる。

==============================================================================

$fe21  __USING      double → 10進文字列        (a0)～ = d0:d1,d2.d3,d4

引数    d0:d1   倍精度浮動小数点数
        d2.l    整数部の桁数
        d3.l    小数部の桁数
        d4.l    属性
                bit 6   正数の場合スペースを、負数の場合"-"を最後尾に付加する
                bit 5   正数の場合"+"を、負数の場合"-"を最後尾に付加する
                bit 4   正数の場合"+"を先頭に付加する
                bit 3   指数形式で表現する
                bit 2   整数部分を３桁ごとに","で区切る
                bit 1   先頭に"\"を付加する
                bit 0   整数部の指定桁数に満たない部分(左側)を"*"で埋める
                        (通常はスペース)
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l の値は変更されない。

        倍精度浮動小数点数を属性 d4 で指定した形で文字列に変換する。
        属性は各ビットをセットすることで、その機能が有効になる。複数のビットを
        セットすることは可能だが、矛盾する設定を行なってはいけない。
        d3.l が負数の場合は 0 として扱われる。ただし、実際には最下位バイトだけ
        が符号なしバイト値として参照される。更に小数点 '.' が挿入されない。

不具合
        整数部の数字が 255 バイトを超える場合はそれ以降の桁(下位桁)の出力が打
        ち切られるため、正しい表現が得られない(d2.l で指定された桁数までのパデ
        ィングは打ち切り後の文字列長に対して適用される)。

==============================================================================

$fe22  __STOD       10進文字列 → double        d0:d1,d2,d3 = (a0)～

引数    a0.l    文字列のアドレス

返値    d0:d1   変換された倍精度浮動小数点数
        d2.w    整数フラグ
        d3.l    整数値
        a0.l    数値の末尾桁の次のアドレス

CCR     C : エラーの時セット
        N : (C = 1)数値の記述法がおかしい場合セット
        V : (C = 1)オーバーフローが発生した場合セット

        文字列を倍精度浮動小数点数に変換する。
        文字列が整数で、かつロングワード符号付き整数で表現可能な場合、整数フラ
        グ d2 は -1 になり d3 にはその整数値が入る。それ以外の場合は d2 = 0 に
        なる。

==============================================================================

$fe23  __DTOS       double → 10進文字列        (a0)～ = d0:d1

引数    d0:d1   倍精度浮動小数点数
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

    　倍精度浮動小数点数を文字列に変換する。

不具合
    該当環境: FLOAT2.X 2.03、FLOAT3.X 2.03、FLOAT4.X 1.02
    　d2 レジスタの値が破壊される。

==============================================================================

$fe24  __ECVT       double → 文字列            (a0),d0,d1 = d0:d1,d2全体桁

引数    d0:d1   倍精度浮動小数点数
        d2.b    全体の桁数
        a0.l    バッファのアドレス

返値    d0.l    小数点の位置
        d1.l    符号(0:正 1:負)
        (a0)～  変換された文字列
        a0.l の値は変更されない。

        倍精度浮動小数点数を全体の桁数を指定して文字列に変換する。
        無限大、非数の場合はそれぞれ "#INF"、"#NAN" を書き込むのでバッファは最
        低でも 5 バイト(NUL の分を含む)が必要である。

==============================================================================

$fe25  __FCVT       double → 文字列            (a0),d0,d1 = d0:d1,d2小数点桁

引数    d0:d1   倍精度浮動小数点数
        d2.b    小数点以下の桁数
        a0.l    バッファのアドレス

返値    d0.l    小数点の位置
        d1.l    符号(0:正 1:負)
        (a0)～  変換された文字列
        a0.l の値は変更されない。

        倍精度浮動小数点数を、小数点以下の桁数を指定して文字列に変換する。
        無限大、非数の場合はそれぞれ "#INF"、"#NAN" を書き込むのでバッファは最
        低でも 5 バイト(NUL の分を含む)が必要である。

        整数部の数字が 255 バイトを超える場合はそれ以降の桁(下位桁)の出力が打
        ち切られるため、そのままでは正しい表現が得られないが、返り値の d0.l で
        示される小数点の位置は(文字列末尾を超えてはいるが)正しい値が得られる。

        絶対値が 1 未満の数の場合は整数部は出力されず、小数部の上位桁の 0 が省
        略される。引数の d2.b で指定した桁数は出力する桁数ではなく小数第一位か
        らの桁数のため、出力される文字列の長さは省略した桁数が差し引かれたもの
        となる。

==============================================================================

$fe26  __GCVT       double → 文字列            (a0)～ = d0:d1,d2全体桁

引数    d0:d1   倍精度浮動小数点数
        d2.b    全体の桁数
        a0.l    バッファのアドレス

返値    d0.l    小数点の位置
        d1.l    符号(0:正 1:負)
        (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

        倍精度浮動小数点数を、全体の桁数を指定した浮動小数点表記または指数表現
        に変換する。負数の場合は文字列の先頭に"-"が付加される。通常は浮動小数
        点表記に変換されるが、桁数 d2 で表現できない場合に指数表現に変換される。
        無限大、非数の場合はそれぞれ "#INF"、"#NAN" を書き込むのでバッファは最
        低でも 5 バイト(NUL の分を含む)が必要である。

==============================================================================

$fe28  __DTST       double 0 比較               Z,N = d0:d1

引数    d0:d1   倍精度浮動小数点数

CCR     Z : d0:d1 が 0 の時セット
        N : d0:d1 が負数の時セット

        d0:d1 で与える倍精度浮動小数点数と 0 を比較し、結果をフラグで返す。

==============================================================================

$fe29  __DCMP       double 比較                 Z,C = d0:d1-d2:d3

引数    d0:d1   被比較数
        d2:d3   比較数

CCR     N : 比較した結果が負数の時セット
        Z :     〃          0 の時セット
        C : ボローが発生した時セット

        倍精度浮動小数点数同士を比較する。被比較数 d0:d1 から比較数 d2:d3 を引
        いた結果がフラグにのみ返される。
        フラグの結果によって次のような関係を導き出すことが出来る。

        d0:d1 > d2:d3   C=0,Z=0,N=0
        d0:d1 = d2:d3   C=0,Z=1,N=0
        d0:d1 < d2:d3   C=1,Z=0,N=1

==============================================================================

$fe2a  __DNEG       double 符号反転             d0:d1 = neg(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

        倍精度浮動小数点数の符号を反転する。

==============================================================================

$fe2b  __DADD       double 加算                 d0:d1 += d2:d3

引数    d0:d1   被加算数
        d2:d3   加算数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        倍精度浮動小数点数同士を加算する。

==============================================================================

$fe2c  __DSUB       double 減算                 d0:d1 -= d2:d3

引数    d0:d1   被減算数
        d2:d3   減算数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        倍精度浮動小数点数同士を減算する。

==============================================================================

$fe2d  __DMUL       double 乗算                 d0:d1 *= d2:d3

引数    d0:d1   被乗数
        d2:d3   乗数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        倍精度浮動小数点数同士を乗算する。

==============================================================================

$fe2e  __DDIV       double 除算                 d0:d1 /= d2:d3

引数    d0:d1   被除数
        d2:d3   除数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア
        Z : (C = 1)0 で割った時セット

        倍精度浮動小数点数同士を除算する。

==============================================================================

$fe2f  __DMOD       double 除算の剰余           d0:d1 %= d2:d3

引数    d0:d1   被除数
        d2:d3   除数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア
        Z : (C = 1)0 で割った時セット

        倍精度浮動小数点数同士の剰余を求める。

==============================================================================

$fe30  __DABS       double 絶対値               d0:d1 = abs(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

        倍精度浮動小数点数の絶対値を求める。

==============================================================================

$fe31  __DCEIL      double 小数切上             d0:d1 = ceil(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

        d0:d1 で与えた倍精度浮動小数点数と等しいか、それ以上の最小の整数を返す。

==============================================================================

$fe32  __DFIX       double 整数部               d0:d1 = fix(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

        d0:d1 で与えた倍精度浮動小数点数の整数部を求める。

==============================================================================

$fe33  __DFLOOR     double 小数切捨             d0:d1 = floor(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

        d0:d1 で与えた倍精度浮動小数点数と等しいか、それより小さい最大の整数を
        返す。

==============================================================================

$fe34  __DFRAC      double 小数部               d0:d1 = frac(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

        d0:d1 で与えた倍精度浮動小数点数の小数部を求める。

==============================================================================

$fe35  __DSGN       double 正負零               d0:d1 = sgn(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   結果(倍精度浮動小数点数)

        d0:d1 で与えた倍精度浮動小数点数が正か負か 0 かを調べる。
        正なら +1.0、負なら -1.0、0 なら 0.0 を返す。

==============================================================================

$fe36  __SIN        double 正弦                 d0:d1 = sin(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

        角度(ラジアン単位)を与えて正弦を計算する。

==============================================================================

$fe37  __COS        double 余弦                 d0:d1 = cos(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

        角度(ラジアン単位)を与えて余弦を計算する。

==============================================================================

$fe38  __TAN        double 正接                 d0:d1 = tan(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

CCR     C : エラーの時セット

        角度(ラジアン単位)を与えて正接を計算する。
        結果が無限大になるような角度を与えた場合はエラーになる。

==============================================================================

$fe39  __ATAN       double 逆正接               d0:d1 = atan(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

        角度(ラジアン単位)を与えて逆正接を計算する。

==============================================================================

$fe3a  __LOG        double 自然対数             d0:d1 = ln(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        Z : (C = 1)引数が 0 の場合セット

        自然対数を計算する。引数が 0 以下の場合はエラーになる。

==============================================================================

$fe3b  __EXP        double 指数関数             d0:d1 = exp(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

CCR     C : エラーの時セット

        指数関数を計算する。オーバーフローが発生した場合はエラーになる。

==============================================================================

$fe3c  __SQR        double 平方根               d0:d1 = sqr(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        Z : (C = 1)引数が 0 の場合セット

        平方根を計算する。オーバーフローが発生した場合はエラーになる。

==============================================================================

$fe3d  __PI         double 円周率               d0:d1 = pi()

返値    d0:d1   円周率

        円周率を倍精度浮動小数点数の範囲内で返す。

==============================================================================

$fe3e  __NPI        double 円周率乗算           d0:d1 = pi(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

CCR     C : エラーの時セット

        円周率の引数倍の値を倍精度浮動小数点数の範囲内で返す。
        オーバーフローが発生した場合はエラーになる。

==============================================================================

$fe3f  __POWER      double 羃乗                 d0:d1 = pow(d0:d1,d2:d3)

引数    d0:d1   被羃乗数
        d2:d3   羃乗数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

    　羃乗を計算する。オーバーフロー/アンダーフローが発生した場合はエラーにな
    る。

==============================================================================

$fe40  __RND        double 乱数                 d0:d1 = rnd()

返値    d0:d1   乱数(倍精度浮動小数点数)

        倍精度浮動小数点数で 0.0 以上 +1.0 未満の乱数を返す。

==============================================================================

$fe41  __SINH       double 双曲正弦             d0:d1 = sinh(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの時セット

        角度(ラジアン単位)を与えて双曲正弦を計算する。

==============================================================================

$fe42  __COSH       double 双曲余弦             d0:d1 = cosh(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの時セット

        角度(ラジアン単位)を与えて双曲余弦を計算する。

==============================================================================

$fe43  __TANH       double 双曲正接             d0:d1 = tanh(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの時セット

        角度(ラジアン単位)を与えて双曲正接を計算する。

==============================================================================

$fe44  __ATANH      double 双曲逆正接           d0:d1 = atanh(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

CCR     C : エラーの時セット

        角度(ラジアン単位)を与えて逆正接を計算する。

==============================================================================

$fe45  __ASIN       double 逆正弦               d0:d1 = asin(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

CCR     C : エラーの時セット

        角度(ラジアン単位)を与えて逆正弦を計算する。

==============================================================================

$fe46  __ACOS       double 逆余弦               d0:d1 = acos(d0:d1)

引数    d0:d1   角度(ラジアン単位、倍精度浮動小数点数)

返値    d0:d1   演算結果

CCR     C : エラーの時セット

        角度(ラジアン単位)を与えて逆余弦を計算する。

==============================================================================

$fe47  __LOG10      double 常用対数             d0:d1 = log10(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        Z : (C = 1)引数が 0 の場合セット

        常用対数を計算する。引数が 0 以下の場合はエラーになる。

==============================================================================

$fe48  __LOG2       double 対数(底2)            d0:d1 = log2(d0:d1)

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

CCR     C : エラーの時セット
        Z : (C = 1)引数が 0 の場合セット

        底が 2 の対数を計算する。引数が 0 以下の場合はエラーになる。

==============================================================================

$fe49  __DFREXP     double 仮数指数分割         d0:d1,d2 = d0:d1

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   仮数部を示す倍精度浮動小数点数
        d2.l    指数部を示すロングワード符号付き整数

        倍精度浮動小数点数の仮数部と指数部を分ける。
        返値の d0:d1 は、引数の仮数部はそのままで指数部を 1 に変えたものを返す。

==============================================================================

$fe4a  __DLDEXP     double 仮数指数結合         d0:d1 = d0:d1,d2

引数    d0:d1   仮数部データ(倍精度浮動小数点数)
        d2.l    指数部データ(ロングワード符号付き整数)

返値    d0:d1   引数を結合した倍精度浮動小数点数

CCR     C : エラーの時セット

        引数の仮数部データ d0:d1 と指数部データ d2 を結合した倍精度浮動小数点
        数を返す。

==============================================================================

$fe4b  __DADDONE    double 1 加算               d0:d1 += 1.0

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

        引数の倍精度浮動小数点数に 1.0 を加える。

==============================================================================

$fe4c  __DSUBONE    double 1 減算               d0:d1 -= 1.0

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

        引数の倍精度浮動小数点数から 1.0 を引く。

==============================================================================

$fe4d  __DDIVTWO    double 2 除算               d0:d1 /= 2.0

引数    d0:d1   倍精度浮動小数点数

返値    d0:d1   演算結果

CCR     C : エラーの時セット

        引数の倍精度浮動小数点数を 2.0 で割る。
        アンダーフローが発生した場合はエラーになる。

==============================================================================

$fe4e  __DIEECNV    double SHARP → IEEE        d0:d1 = d0:d1

引数    d0:d1   SHARP フォーマット倍精度浮動小数点数

返値    d0:d1   IEEE 〃

        SHARP フォーマット倍精度浮動小数点数を IEEE フォーマットに変換する。
        FLOAT1.X 以外では意味を持たない。

==============================================================================

$fe4f  __IEEDCNV    double IEEE → SHARP        d0:d1 = d0:d1

引数    d0:d1   IEEE フォーマット倍精度浮動小数点数

返値    d0:d1   SHARP 〃

        SHARP フォーマット倍精度浮動小数点数を IEEE フォーマットに変換する。
        FLOAT1.X 以外では意味を持たない。

==============================================================================

$fe50  __FVAL       文字列 → float             d0 = (a0)～

引数    a0.l    文字列のアドレス

返値    d0.l    変換された単精度浮動小数点数
        d2.w    整数フラグ(文字列が10進数だった場合に有効)
        d3.l    整数値    (〃)
        a0.l    数値の末尾桁の次のアドレス

CCR     C : エラーの時セット
        N : (C = 1)数値の記述法がおかしい場合セット
        V : (C = 1)オーバーフローが発生した場合セット

        文字列を単精度浮動小数点数に変換する。文字列の先頭に"&H","&O","&B"がつ
        いていている場合は、それぞれ16,8,2進数で表現されているものと扱う。
        文字列が10進数だった場合、返値として d2,d3 が有効になる。文字列が整数
        でかつロングワード符号付き整数で表現可能な場合、整数フラグ d2 は -1 に
        なり d3 にはその整数値が入る。それ以外の場合は d2 = 0 になる。

==============================================================================

$fe51  __FUSING     float → 10進文字列         (a0)～ = d0,d2.d3,d4

引数    d0.l    単精度浮動小数点数
        d2.l    整数部の桁数
        d3.l    小数部の桁数
        d4.l    属性
                bit 6   正数の場合スペースを、負数の場合"-"を最後尾に付加する
                bit 5   正数の場合"+"を、負数の場合"-"を最後尾に付加する
                bit 4   正数の場合"+"を先頭に付加する
                bit 3   指数形式で表現する
                bit 2   整数部分を３桁ごとに","で区切る
                bit 1   先頭に"\"を付加する
                bit 0   整数部の指定桁数に満たない部分(左側)を"*"で埋める
                        (通常はスペース)
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l の値は変更されない。

        単精度浮動小数点数を属性 d4 で指定した形で文字列に変換する。
        d3.l が負数の場合は 0 として扱われる。ただし、実際には最下位バイトだけ
        が符号なしバイト値として参照される。更に小数点 '.' が挿入されない。

==============================================================================

$fe52  __STOF       10進文字列 → float         d0,d2,d3 = (a0)～

引数    a0.l    文字列のアドレス

返値    d0.l    変換された単精度浮動小数点数
        d2.w    整数フラグ
        d3.l    整数値
        a0.l    数値の末尾桁の次のアドレス

CCR     C : エラーの時セット
        N : (C = 1)数値の記述法がおかしい場合セット
        V : (C = 1)オーバーフローが発生した場合セット

        文字列を単精度浮動小数点数に変換する。
        文字列が整数で、かつロングワード符号付き整数で表現可能な場合、整数フラ
        グ d2 は -1 になり d3 にはその整数値が入る。それ以外の場合は d2 = 0 に
        なる。

==============================================================================

$fe53  __FTOS       float → 10進文字列         (a0)～ = d0

引数    d0.l    単精度浮動小数点数
        a0.l    バッファのアドレス

返値    (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

    　単精度浮動小数点数を文字列に変換する。

不具合
    該当環境: FLOAT2.X 2.03、FLOAT3.X 2.03、FLOAT4.X 1.02
    　d2 レジスタの値が破壊される。

==============================================================================

$fe54  __FECVT      float → 文字列             (a0),d0,d1 = d0,d2全体桁

引数    d0.l    単精度浮動小数点数
        d2.b    全体の桁数
        a0.l    バッファのアドレス

返値    d0.l    小数点の位置
        d1.l    符号(0:正 1:負)
        (a0)～  変換された文字列
        a0.l の値は変更されない。

        単精度浮動小数点数を全体の桁数を指定して文字列に変換する。
        無限大、非数の場合はそれぞれ "#INF"、"#NAN" を書き込むのでバッファは最
        低でも 5 バイト(NUL の分を含む)が必要である。

==============================================================================

$fe55  __FFCVT      float → 文字列             (a0),d0,d1 = d0,d2小数点桁

引数    d0.l    単精度浮動小数点数
        d2.b    小数点以下の桁数
        a0.l    バッファのアドレス

返値    d0.l    小数点の位置
        d1.l    符号(0:正 1:負)
        (a0)～  変換された文字列
        a0.l の値は変更されない。

        単精度浮動小数点数を、小数点以下の桁数を指定して文字列に変換する。
        無限大、非数の場合はそれぞれ "#INF"、"#NAN" を書き込むのでバッファは最
        低でも 5 バイト(NUL の分を含む)が必要である。

==============================================================================

$fe56  __FGCVT      float → 文字列             (a0)～ = d0,d2全体桁

引数    d0.l    単精度浮動小数点数
        d2.b    全体の桁数
        a0.l    バッファのアドレス

返値    d0.l    小数点の位置
        d1.l    符号(0:正 1:負)
        (a0)～  変換された文字列
        a0.l    文字列の末尾のアドレス

        単精度浮動小数点数を、全体の桁数を指定した浮動小数点表記または指数表現
        に変換する。負数の場合は文字列の先頭に"-"が付加される。通常は浮動小数
        点表記に変換されるが、桁数 d2 で表現できない場合に指数表現に変換される。
        無限大、非数の場合はそれぞれ "#INF"、"#NAN" を書き込むのでバッファは最
        低でも 5 バイト(NUL の分を含む)が必要である。

==============================================================================

$fe58  __FTST       float 0 比較                Z,N = d0

引数    d0.l    単精度浮動小数点数

CCR     Z : d0 が 0 の時セット
        N : d0 が負数の時セット

        d0 で与える単精度浮動小数点数と 0 を比較し、結果をフラグで返す。

==============================================================================

$fe59  __FCMP       float 比較                  Z,C = d0-d1

引数    d0.l    被比較数
        d1.l    比較数

CCR     N : 比較した結果が負数の時セット
        Z :     〃          0 の時セット
        C : ボローが発生した時セット

        単精度浮動小数点数同士を比較する。被比較数 d0 から比較数 d1 を引いた結
        果がフラグにのみ返される。
        フラグの結果によって次のような関係を導き出すことが出来る。

        d0 > d1         C=0,Z=0,N=0
        d0 = d1         C=0,Z=1,N=0
        d0 < d1         C=1,Z=0,N=1

==============================================================================

$fe5a  __FNEG       float 符号反転              d0 = neg(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

        単精度浮動小数点数の符号を反転する。

==============================================================================

$fe5b  __FADD       float 加算                  d0 += d1

引数    d0.l    被加算数
        d1.l    加算数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        単精度浮動小数点数同士を加算する。

==============================================================================

$fe5c  __FSUB       float 減算                  d0 -= d1

引数    d0.l    被減算数
        d1.l    減算数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        単精度浮動小数点数同士を減算する。

==============================================================================

$fe5d  __FMUL       float 乗算                  d0 *= d1

引数    d0.l    被乗数
        d1.l    乗数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        単精度浮動小数点数同士を乗算する。

==============================================================================

$fe5e  __FDIV       float 除算                  d0 /= d1

引数    d0.l    被除数
        d1.l    除数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア
        Z : (C = 1)0 で割った時セット

        単精度浮動小数点数同士を除算する。

==============================================================================

$fe5f  __FMOD       float 除算の剰余            d0 %= d1

引数    d0.l    被除数
        d1.l    除数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア
        Z : (C = 1)0 で割った時セット

        単精度浮動小数点数同士の剰余を求める。

==============================================================================

$fe60  __FABS       float 絶対値                d0 = abs(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

        単精度浮動小数点数の絶対値を求める。

==============================================================================

$fe61  __FCEIL      float 小数切上              d0 = ceil(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

        d0 で与えた単精度浮動小数点数と等しいか、それ以上の最小の整数を返す。

==============================================================================

$fe62  __FFIX       float 整数部                d0 = fix(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

        d0 で与えた単精度浮動小数点数の整数部を求める。

==============================================================================

$fe63  __FFLOOR     float 小数切捨              d0 = floor(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

        d0 で与えた単精度浮動小数点数と等しいか、それより小さい最大の整数を返
        す。

==============================================================================

$fe64  __FFRAC      float 小数部                d0 = frac(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

        d0 で与えた単精度浮動小数点数の小数部を求める。

==============================================================================

$fe65  __FSGN       float 正負零                d0 = sgn(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    結果(単精度浮動小数点数)

        d0 で与えた単精度浮動小数点数が正か負か 0 かを調べる。
        正なら +1.0、負なら -1.0、0 なら 0.0 を返す。

==============================================================================

$fe66  __FSIN       float 正弦                  d0 = sin(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

        角度(ラジアン単位)を与えて正弦を計算する。

==============================================================================

$fe67  __FCOS       float 余弦                  d0 = cos(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

        角度(ラジアン単位)を与えて余弦を計算する。

==============================================================================

$fe68  __FTAN       float 正接                  d0 = tan(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

CCR     C : エラーの時セット

        角度(ラジアン単位)を与えて正接を計算する。
        結果が無限大になるような角度を与えた場合はエラーになる。

==============================================================================

$fe69  __FATAN      float 逆正接                d0 = atan(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

        角度(ラジアン単位)を与えて逆正接を計算する。

==============================================================================

$fe6a  __FLOG       float 自然対数              d0 = ln(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        Z : (C = 1)引数が 0 の場合セット

        自然対数を計算する。引数が 0 以下の場合はエラーになる。

==============================================================================

$fe6b  __FEXP       float 指数関数              d0 = exp(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

CCR     C : エラーの時セット

        指数関数を計算する。オーバーフローが発生した場合はエラーになる。

==============================================================================

$fe6c  __FSQR       float 平方根                d0 = sqr(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        Z : (C = 1)引数が 0 の場合セット

        平方根を計算する。オーバーフローが発生した場合はエラーになる。

==============================================================================

$fe6d  __FPI        float 円周率                d0 = pi()

返値    d0.l    円周率

        円周率を単精度浮動小数点数の範囲内で返す。

==============================================================================

$fe6e  __FNPI       float 円周率乗算            d0 = pi(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

CCR     C : エラーの時セット

        円周率の引数倍の値を単精度浮動小数点数の範囲内で返す。
        オーバーフローが発生した場合はエラーになる。

==============================================================================

$fe6f  __FPOWER     float 羃乗                  d0 = pow(d0,d1)

引数    d0.l    被羃乗数
        d1.l    羃乗数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        羃乗を計算する。オーバーフロー/アンダーフローが発生した場合はエラーに
        なる。

==============================================================================

$fe70  __FRND       float 乱数                  d0 = rnd()

返値    d0.l    乱数(単精度浮動小数点数)

        単精度浮動小数点数で 0 以上 1 未満の乱数を返す。

==============================================================================

$fe71  __FSINH      float 正弦                  d0 = sinh(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの時セット

        角度(ラジアン単位)を与えて双曲正弦を計算する。

==============================================================================

$fe72  __FCOSH      float 双曲余弦              d0 = cosh(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの時セット

        角度(ラジアン単位)を与えて双曲余弦を計算する。

==============================================================================

$fe73  __FTANH      float 双曲正接              d0 = tanh(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの時セット

        角度(ラジアン単位)を与えて双曲正接を計算する。

==============================================================================

$fe74  __FATANH     float 双曲逆正接            d0 = atanh(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

CCR     C : エラーの時セット

        角度(ラジアン単位)を与えて逆正接を計算する。

==============================================================================

$fe75  __FASIN      float 逆正弦                d0 = asin(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

CCR     C : エラーの時セット

        角度(ラジアン単位)を与えて逆正弦を計算する。

==============================================================================

$fe76  __FACOS      float 逆余弦                d0 = acos(d0)

引数    d0.l    角度(ラジアン単位、単精度浮動小数点数)

返値    d0.l    演算結果

CCR     C : エラーの時セット

        角度(ラジアン単位)を与えて逆余弦を計算する。

==============================================================================

$fe77  __FLOG10     float 常用対数              d0 = log10(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        Z : (C = 1)引数が 0 の場合セット

        常用対数を計算する。引数が 0 以下の場合はエラーになる。

==============================================================================

$fe78  __FLOG2      float 対数(底2)             d0 = log2(d0)

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

CCR     C : エラーの時セット
        Z : (C = 1)引数が 0 の場合セット

        底が 2 の対数を計算する。引数が 0 以下の場合はエラーになる。

==============================================================================

$fe79  __FFREXP     float 仮数指数分割          d0,d1 = d0

引数    d0.l    単精度浮動小数点数

返値    d0.l    仮数部を示す単精度浮動小数点数
        d1.l    指数部を示すロングワード符号付き整数

        単精度浮動小数点数の仮数部と指数部を分ける。
        返値の d0 は、引数の仮数部はそのままで指数部を 1 に変えたものを返す。

==============================================================================

$fe7a  __FLDEXP     float 仮数指数結合          d0 = d0,d1

引数    d0.l    仮数部データ(単精度浮動小数点数)
        d1.l    指数部データ(ロングワード符号付き整数)

返値    d0.l    引数を結合した単精度浮動小数点数

CCR     C : エラーの時セット

        引数の仮数部データ d0 と指数部データ d1 を結合した単精度浮動小数点数を
        返す。

==============================================================================

$fe7b  __FADDONE    float 1 加算                d0 += 1.0

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

        引数の単精度浮動小数点数に 1.0 を加える。

==============================================================================

$fe7c  __FSUBONE    float 1 減算                d0 -= 1.0

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

        引数の単精度浮動小数点数から 1.0 を引く。

==============================================================================

$fe7d  __FDIVTWO    float 2 除算                d0 /= 2.0

引数    d0.l    単精度浮動小数点数

返値    d0.l    演算結果

CCR     C : エラーの時セット

        引数の単精度浮動小数点数を 2.0 で割る。
        アンダーフローが発生した場合はエラーになる。

==============================================================================

$fe7e  __FIEECNV    float SHARP → IEEE         d0 = d0

引数    d0.l    SHARP フォーマット単精度浮動小数点数

返値    d0.l    IEEE 〃

        SHARP フォーマット単精度浮動小数点数を IEEE フォーマットに変換する。
        FLOAT1.X 以外では意味を持たない。

==============================================================================

$fe7f  __IEEFCNV    float IEEE → SHARP         d0 = d0

引数    d0.l    IEEE フォーマット単精度浮動小数点数

返値    d0.l    SHARP 〃

        SHARP フォーマット単精度浮動小数点数を IEEE フォーマットに変換する。
        FLOAT1.X 以外では意味を持たない。

==============================================================================

$fee0  __CLMUL      signed int 乗算             (sp) *= (4,sp)

引数    (sp).l          被乗数
        (4,sp).l        乗数

返値    (sp).l          演算結果

CCR     C : エラーの時セット

        ロングワード符号付き整数同士の乗算を行なう。
        演算結果がロングワード符号付き整数の範囲を超えた場合はエラーとなる。

==============================================================================

$fee1  __CLDIV      signed int 除算             (sp) /= (4,sp)

引数    (sp).l          被除数
        (4,sp).l        除数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、ゼロ除算の場合はクリア
        Z : (C = 1)ゼロ除算の場合はセット、オーバーフローの場合はクリア

        ロングワード符号付き整数同士の除算を行なう。
        除数が 0 の場合はエラーとなる。

==============================================================================

$fee2  __CLMOD      signed int 除算の剰余       (sp) %= (4,sp)

引数    (sp).l          被除数
        (4,sp).l        除数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)ゼロ除算の場合はクリア
        Z : (C = 1)ゼロ除算の場合はセット

        ロングワード符号付き整数同士の除算の剰余を計算する。
        除数が 0 の場合はエラーとなる。

==============================================================================

$fee3  __CUMUL      unsigned int 乗算           (sp) *= (4,sp)

引数    (sp).l          被乗数
        (4,sp).l        乗数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット
        Z : (C = 1)オーバーフローの場合はクリア

        ロングワード符号なし整数同士の乗算を行なう。
        演算結果がロングワード符号なし整数の範囲を超えた場合はエラーとなる。

==============================================================================

$fee4  __CUDIV      unsigned int 除算           (sp) /= (4,sp)

引数    (sp).l          被除数
        (4,sp).l        除数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)ゼロ除算の場合はクリア
        Z : (C = 1)ゼロ除算の場合はセット

        ロングワード符号なし整数同士の除算の商を計算する。
        除数が 0 の場合はエラーとなる。

==============================================================================

$fee5  __CUMOD      unsigned int 除算の剰余     (sp) %= (4,sp)

引数    (sp).l          被除数
        (4,sp).l        除数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)ゼロ除算の場合はクリア
        Z : (C = 1)ゼロ除算の場合はセット

        ロングワード符号なし整数同士の除算の剰余を計算する。
        除数が 0 の場合はエラーとなる。

==============================================================================

$fee6  __CLTOD      signed int → double        (sp):(4,sp) = (sp)

引数    (sp).l          ロングワード符号付き整数

返値    (sp):(4,sp)     変換された倍精度浮動小数点数

        ロングワード符号付き整数を倍精度浮動小数点数に変換する。
        引数は 4 バイト、返値は 8 バイトであることに注意すること。

==============================================================================

$fee7  __CDTOL      double → signed int        (sp) = (sp):(4,sp)

引数    (sp):(4,sp)     倍精度浮動小数点数

返値    (sp).l          変換されたロングワード符号付き整数

CCR     C : エラーの時セット

        倍精度浮動小数点数をロングワード符号付き整数に変換する。小数部は切り捨
        てられる。
        変換結果がロングワード符号付き整数の範囲を超えた場合はエラーとなる。
        引数は 8 バイト、返値は 4 バイトであることに注意すること。

==============================================================================

$fee8  __CLTOF      signed int → float         (sp) = (sp)

引数    (sp).l          ロングワード符号付き整数

返値    (sp).l          変換された単精度浮動小数点数

        ロングワード符号付き整数を単精度浮動小数点数に変換する。

==============================================================================

$fee9  __CFTOL      float → signed int         (sp) = (sp)

引数    (sp).l          単精度浮動小数点数

返値    (sp).l          変換されたロングワード符号付き整数

CCR     C : エラーの時セット

        単精度浮動小数点数をロングワード符号付き整数に変換する。
        変換結果がロングワード符号付き整数の範囲を超えた場合はエラーとなる。

==============================================================================

$feea  __CFTOD      float → double             (sp):(4,sp) = (sp)

引数    (sp).l          単精度浮動小数点数

返値    (sp):(4,sp)     変換された倍精度浮動小数点数

        単精度浮動小数点数を倍精度浮動小数点数に変換する。
        引数は 4 バイト、返値は 8 バイトであることに注意すること。

==============================================================================

$feeb  __CDTOF      double → float             (sp) = (sp):(4,sp)

引数    (sp):(4,sp)     倍精度浮動小数点数

返値    (sp).l          変換された単精度浮動小数点数

CCR     C : エラーの時セット

        倍精度浮動小数点数を単精度浮動小数点数に変換する。
        引数が単精度浮動小数点数で表現できない場合はエラーとなる。

==============================================================================

$feec  __CDCMP      double 比較                 Z,C = (sp):(4,sp)-(8,sp):(12,sp)

引数      (sp):(4,sp)   被比較数
        (8,sp):(12,sp)  比較数

返値    (sp):(4,sp)     演算結果

CCR     N : 比較した結果が負数の時セット
        Z :     〃          0 の時セット
        C : ボローが発生した時セット

        倍精度浮動小数点数同士を比較する。被比較数 (sp):(4,sp) から比較数
        (8,sp):(12,sp) を引いた結果がフラグにのみ返される。
        フラグの結果によって次のような関係を導き出すことが出来る。

        (sp):(4,sp) > (8,sp):(12,sp)    C=0,Z=0,N=0
        (sp):(4,sp) = (8,sp):(12,sp)    C=0,Z=1,N=0
        (sp):(4,sp) < (8,sp):(12,sp)    C=1,Z=0,N=1

==============================================================================

$feed  __CDADD      double 加算                 (sp):(4,sp) += (8,sp):(12,sp)

引数      (sp):(4,sp)   被加算数
        (8,sp):(12,sp)  加算数

返値    (sp):(4,sp)     演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        倍精度浮動小数点数同士を加算する。

==============================================================================

$feee  __CDSUB      double 減算                 (sp):(4,sp) -= (8,sp):(12,sp)

引数      (sp):(4,sp)   被減算数
        (8,sp):(12,sp)  減算数

返値    (sp):(4,sp)     演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        倍精度浮動小数点数同士を減算する。

==============================================================================

$feef  __CDMUL      double 乗算                 (sp):(4,sp) *= (8,sp):(12,sp)

引数      (sp):(4,sp)   被乗数
        (8,sp):(12,sp)  乗数

返値    (sp):(4,sp)     演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        倍精度浮動小数点数同士を乗算する。

==============================================================================

$fef0  __CDDIV      double 除算                 (sp):(4,sp) /= (8,sp):(12,sp)

引数      (sp):(4,sp)   被除数
        (8,sp):(12,sp)  除数

返値    (sp):(4,sp)     演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア
        Z : (C = 1)0 で割った時セット

        倍精度浮動小数点数同士を除算する。

==============================================================================

$fef1  __CDMOD      double 除算の剰余           (sp):(4,sp) %= (8,sp):(12,sp)

引数      (sp):(4,sp)   被除数
        (8,sp):(12,sp)  除数

返値    (sp):(4,sp)     演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア
        Z : (C = 1)0 で割った時セット

        倍精度浮動小数点数同士の剰余を求める。

==============================================================================

$fef2  __CFCMP      float 比較                  Z,C = (sp)-(4,sp)

引数    (sp).l          被比較数
        (4,sp).l        比較数

CCR     N : 比較した結果が負数の時セット
        Z :     〃          0 の時セット
        C : ボローが発生した時セット

        単精度浮動小数点数同士を比較する。被比較数 (sp) から比較数 (4,sp) を引
        いた結果がフラグにのみ返される。
        フラグの結果によって次のような関係を導き出すことが出来る。

        (sp) > (4,sp)   C=0,Z=0,N=0
        (sp) = (4,sp)   C=0,Z=1,N=0
        (sp) < (4,sp)   C=1,Z=0,N=1

==============================================================================

$fef3  __CFADD      float 加算                  (sp) += (4,sp)

引数    (sp).l          被加算数
        (4,sp).l        加算数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        単精度浮動小数点数同士を加算する。

==============================================================================

$fef4  __CFSUB      float 減算                  (sp) -= (4,sp)

引数    (sp).l          被減算数
        (4,sp).l        減算数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        単精度浮動小数点数同士を減算する。

==============================================================================

$fef5  __CFMUL      float 乗算                  (sp) *= (4,sp)

引数    (sp).l          被乗数
        (4,sp).l        乗数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア

        単精度浮動小数点数同士を乗算する。

==============================================================================

$fef6  __CFDIV      float 除算                  (sp) /= (4,sp)

引数    (sp).l          被除数
        (4,sp).l        除数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア
        Z : (C = 1)0 で割った時セット

        単精度浮動小数点数同士を除算する。

==============================================================================

$fef7  __CFMOD      float 除算の剰余            (sp) %= (4,sp)

引数    (sp).l          被除数
        (4,sp).l        除数

返値    (sp).l          演算結果

CCR     C : エラーの時セット
        V : (C = 1)オーバーフローの場合はセット、アンダーフローの場合はクリア
        Z : (C = 1)0 で割った時セット

        単精度浮動小数点数同士の剰余を求める。

==============================================================================

$fef8  __CDTST      double 0 比較               Z,N = (sp):(4,sp)

引数    (sp):(4,sp)     倍精度浮動小数点数

CCR     Z : (sp):(4,sp) が 0 の時セット
        N : (sp):(4,sp) が負数の時セット

        (sp):(4,sp) で与える倍精度浮動小数点数と 0 を比較し、結果をフラグで返
        す。

==============================================================================

$fef9  __CFTST      float 0 比較                Z,N = (sp)

引数    (sp).l  単精度浮動小数点数

CCR     Z : (sp) が 0 の時セット
        N : (sp) が負数の時セット

        (sp) で与える単精度浮動小数点数と 0 を比較し、結果をフラグで返す。

==============================================================================

$fefa  __CDINC      double 1 加算               (sp):(4,sp) += 1.0

引数    (sp):(4,sp)     倍精度浮動小数点数

返値    (sp):(4,sp)     演算結果

        引数の倍精度浮動小数点数に 1.0 を加える。

==============================================================================

$fefb  __CFINC      float 1 加算                (sp) += 1.0

引数    (sp).l  単精度浮動小数点数

返値    (sp).l  演算結果

        引数の単精度浮動小数点数に 1.0 を加える。

==============================================================================

$fefc  __CDDEC      double 1 減算               (sp):(4,sp) -= 1.0

引数    (sp):(4,sp)     倍精度浮動小数点数

返値    (sp):(4,sp)     演算結果

        引数の倍精度浮動小数点数から 1.0 を引く。

==============================================================================

$fefd  __CFDEC      float 1 減算                (sp) -= 1.0

引数    (sp).l  単精度浮動小数点数

返値    (sp).l  演算結果

        引数の単精度浮動小数点数から 1.0 を引く。

==============================================================================

$fefe  __FEVARG     数値演算ドライバ種別検査    d0,d1 = [FORMAT],[MODE]

返値    d0.l    数値演算ドライバ名(1)
        d1.l            〃        (2)

        組み込まれている数値演算デバイスドライバの種類を調べる。

                         d0.l    d1.l
        FLOAT1.X        'HS86'  'SOFT'
        FLOAT2.X        'IEEE'  'SOFT'
        FLOAT3.X        'IEEE'  'FPCP'
        FLOAT4.X        'IEEE'  'FP20'
        FLOAT040.X      'IEEE'  'SOFT'  (FLOAT2.X ベースであるため)
        060turbo.sys    'IEEE'  'FPSP'
        (FLOATEML.L)    'IEEE'  'CLIB'

==============================================================================

$feff  __FEVECS     処理アドレス変更            d0 = intvcs(d0,a0)

引数    d0.l    FETBL 番号($fe00～$fefe)
        a0.l    処理アドレス

返値    d0.l    前の処理アドレス

        d0 で指定した FE ファンクションの処理アドレスを変更する。
        範囲外の番号を入れた場合、エラーとなり d0 に -1 が返る。
        このファンクションコールをサポートするドライバは少ないので注意すること。

==============================================================================
